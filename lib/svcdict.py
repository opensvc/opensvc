import sys

from keywords import KeywordStore
from rcGlobalEnv import rcEnv

SECTIONS = [
    "DEFAULT",
    "sync",
    "ip",
    "fs",
    "disk",
    "share",
    "container",
    "app",
    "task",
    "volume",
]

# deprecated => supported
DEPRECATED_KEYWORDS = {
    "DEFAULT.mode": None,
    "DEFAULT.cluster_type": "topology",
    "DEFAULT.service_type": "env",
    "DEFAULT.affinity": "hard_affinity",
    "DEFAULT.anti_affinity": "hard_anti_affinity",
    "DEFAULT.docker_data_dir": "container_data_dir",
    "DEFAULT.flex_min_nodes": "flex_min",
    "DEFAULT.flex_max_nodes": "flex_max",
    "disk.lvm.vgname": "name",
    "disk.pool.poolname": "name",
    "disk.vg.vgname": "name",
    "sync.rsync.exclude": None,
    "disk.zpool.poolname": "name",
    "always_on": None,
    "container.docker.run_image": "image",
    "container.docker.run_command": "command",
    "container.docker.net": "netns",
    "container.oci.run_image": "image",
    "container.oci.run_command": "command",
    "container.oci.net": "netns",
    "container.podman.run_image": "image",
    "container.podman.run_command": "command",
    "container.podman.net": "netns",
    "task.docker.run_command": "command",
    "task.podman.run_command": "command",
    "ip.docker.container_rid": "netns",
    "ip.netns.container_rid": "netns",
    "ip.cni.container_rid": "netns",
}

# supported => deprecated
REVERSE_DEPRECATED_KEYWORDS = {
    "DEFAULT.topology": "cluster_type",
    "DEFAULT.env": "service_type",
    "DEFAULT.hard_affinity": "affinity",
    "DEFAULT.hard_anti_affinity": "anti_affinity",
    "DEFAULT.container_data_dir": "docker_data_dir",
    "DEFAULT.flex_min": "flex_min_nodes",
    "DEFAULT.flex_max": "flex_max_nodes",
    "container.docker.image": "run_image",
    "container.docker.command": "run_command",
    "container.docker.netns": "net",
    "container.oci.image": "run_image",
    "container.oci.command": "run_command",
    "container.oci.netns": "net",
    "container.podman.image": "run_image",
    "container.podman.command": "run_command",
    "container.podman.netns": "net",
    "disk.lvm.name": "vgname",
    "disk.pool.name": "poolname",
    "disk.vg.name": "vgname",
    "disk.zpool.name": "poolname",
    "ip.docker.netns": "container_rid",
    "ip.netns.netns": "container_rid",
    "ip.cni.netns": "container_rid",
    "task.docker.command": "run_command",
    "task.podman.command": "run_command",
}

DEPRECATED_SECTIONS = {
    "disk.pool": ["disk", "zpool"],
    "disk.veritas": ["disk", "vxdg"],
    "drbd": ["disk", "drbd"],
    "loop": ["disk", "loop"],
    "pool": ["disk", "zpool"],
    "vdisk": ["disk", "vdisk"],
    "vmdg": ["disk", "vmdg"],
    "vg": ["disk", "vg"],
    "ip.docker": ["ip", "netns"],
}

KEYWORDS = [
    {
        "section": "DEFAULT",
        "keyword": "id",
        "inheritance": "head",
        "default_text": "<random uuid>",
        "text": "A RFC 4122 random uuid generated by the agent. To use as reference in resources definitions instead of the service name, so the service can be renamed without affecting the resources."
    },
    {
        "section": "DEFAULT",
        "keyword": "lock_timeout",
        "default": "60s",
        "convert": "duration",
        "text": "A duration expression, like ``1m30s``. The maximum wait time for the action lock acquire. The :cmd:`svcmgr --waitlock` option overrides this parameter."
    },
    {
        "section": "DEFAULT",
        "keyword": "mode",
        "default": "hosted",
        "candidates": ["hosted"],
        "text": "Deprecated. The value is always ``hosted``. The keyword is kept around for now the ease transition from older agents."
    },
    {
        "section": "DEFAULT",
        "keyword": "rollback",
        "at": True,
        "default": True,
        "convert": "boolean",
        "text": "If set to ``false``, the default 'rollback on action error' "
                "behaviour is inhibited, leaving the service in its "
                "half-started state. The daemon also refuses to takeover "
                "a service if rollback is disabled and a peer instance is "
                "'start failed'."
    },
    {
        "section": "DEFAULT",
        "keyword": "comp_schedule",
        "at": True,
        "default": "00:00-06:00@361",
        "text": "The service compliance run schedule. See ``usr/share/doc/schedule`` for the schedule syntax."
    },
    {
        "section": "DEFAULT",
        "keyword": "status_schedule",
        "at": True,
        "default": "@10",
        "text": "The service status evaluation schedule. See ``usr/share/doc/schedule`` for the schedule syntax."
    },
    {
        "section": "DEFAULT",
        "keyword": "sync_schedule",
        "at": True,
        "default": "04:00-06:00@121",
        "text": "The default sync resources schedule. See ``usr/share/doc/schedule`` for the schedule syntax."
    },
    {
        "section": "DEFAULT",
        "keyword": "aws",
        "at": True,
        "text": "The aws cli executable fullpath. If not provided, aws is expected to be found in the PATH."
    },
    {
        "section": "DEFAULT",
        "keyword": "aws_profile",
        "at": True,
        "default": "default",
        "text": "The profile to use with the AWS api."
    },
    {
        "section": "DEFAULT",
        "keyword": "resinfo_schedule",
        "at": True,
        "default": "@60",
        "text": "The service resource info push schedule. See ``usr/share/doc/schedule`` for the schedule syntax."
    },
    {
        "section": "DEFAULT",
        "keyword": "monitor_schedule",
        "at": True,
        "text": "The service resource monitor schedule. See ``usr/share/doc/schedule`` for the schedule syntax."
    },
    {
        "section": "DEFAULT",
        "keyword": "push_schedule",
        "at": True,
        "default": "00:00-06:00@361",
        "text": "The service configuration emission to the collector schedule. See ``usr/share/doc/schedule`` for the schedule syntax."
    },
    {
        "section": "DEFAULT",
        "keyword": "flex_primary",
        "inheritance": "head",
        "convert": "lower",
        "at": True,
        "depends": [('topology', ["flex"])],
        "default_text": "<first node of the nodes parameter>",
        "text": "The node in charge of syncing the other nodes. :opt:`--cluster` actions on the flex_primary are executed on all peer nodes (ie, not drpnodes)."
    },
    {
        "section": "DEFAULT",
        "keyword": "drp_flex_primary",
        "inheritance": "head",
        "convert": "lower",
        "at": True,
        "depends": [('topology', ["flex"])],
        "default_text": "<first node of the drpnodes parameter>",
        "text": "The drpnode in charge of syncing the other drpnodes. :opt:`--cluster` actions on the drp_flex_primary are executed on all drpnodes (ie, not pri nodes)."
    },
    {
        "section": "DEFAULT",
        "keyword": "docker_exe",
        "at": True,
        "text": "If you have multiple docker versions installed and want the service to stick to a version whatever the ``PATH`` definition, you should set this parameter to the full path to the docker executable.",
        "example": "/usr/bin/docker-1.8"
    },
    {
        "section": "DEFAULT",
        "keyword": "dockerd_exe",
        "at": True,
        "text": "If you have multiple docker versions installed and want the service to stick to a version whatever the ``PATH`` definition, you should set this parameter to the full path to the docker daemon executable.",
        "example": "/usr/bin/dockerd-1.8"
    },
    {
        "section": "DEFAULT",
        "keyword": "container_data_dir",
        "at": True,
        "text": "If the service has lxc, docker or podman-type container resources and this keyword is set, the service configures a service-private containers data store. This setup is allows stateful service relocalization.",
        "example": "/srv/svc1/data/containers"
    },
    {
        "section": "container",
        "rtype": "lxc",
        "keyword": "container_data_dir",
        "at": True,
        "text": "If this keyword is set, the service configures a resource-private container data store. This setup is allows stateful service relocalization.",
        "example": "/srv/svc1/data/containers"
    },
    {
        "section": "DEFAULT",
        "keyword": "docker_daemon_private",
        "at": True,
        "default_text": "<true if container_data_dir is set, else false>",
        "convert": "boolean",
        "text": "If set to ``false``, this service will use the system's shared docker daemon instance. This is parameter is forced to ``false`` on non-Linux systems.",
        "example": "True"
    },
    {
        "section": "DEFAULT",
        "keyword": "docker_daemon_args",
        "at": True,
        "convert": "shlex",
        "default": [],
        "text": "If the service has docker-type container resources, the service handles the startup of a private docker daemon. OpenSVC sets the socket and data dir parameters. Admins can set extra parameters using this keyword. For example, it can be useful to set the :opt:`--ip` parameter for a docker registry service.",
        "example": "--ip 1.2.3.4"
    },
    {
        "section": "DEFAULT",
        "keyword": "access",
        "inheritance": "head",
        "depends": [("kind", "vol")],
        "default": "rwo",
        "candidates": ["rwo", "roo", "rwx", "rox"],
        "at": True,
        "required": False,
        "text": "The access mode of the volume. ``rwo`` is Read Write Once, ``roo`` is Read Only Once, ``rwx`` is Read Write Many, ``rox`` is Read Only Many. ``rox`` and ``rwx`` modes are served by flex volume services.",
    },
    {
        "section": "DEFAULT",
        "keyword": "pool",
        "inheritance": "head",
        "depends": [("kind", "vol")],
        "at": True,
        "required": False,
        "text": "The name of the pool this volume was allocated from.",
    },
    {
        "section": "DEFAULT",
        "keyword": "size",
        "inheritance": "head",
        "depends": [("kind", "vol")],
        "convert": "integer",
        "at": True,
        "required": False,
        "text": "The size of the volume allocated from its pool.",
    },
    {
        "section": "subset",
        "keyword": "parallel",
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "If set to ``true``, actions are executed in parallel amongst the subset member resources.",
    },
    {
        "section": "container",
        "keyword": "type",
        "inheritance": "leaf",
        "at": True,
        "candidates": rcEnv.vt_supported,
        "text": "The type of container.",
        "required": False,
        "default": "oci",
    },
    {
        "section": "container",
        "rtype": "zone",
        "keyword": "delete_on_stop",
        "at": True,
        "candidates": (True, False),
        "text": "If set to ``true``, the zone configuration is deleted after a resource stop. The agent maintains an export of the configuration for the next start. This export is replicated to the other nodes and drp nodes so they can take over the zone even if it is completely hosted on a shared disk.",
        "default": False,
        "convert": "boolean",
    },
    {
        "section": "container",
        "rtype": "zone",
        "keyword": "zonepath",
        "at": True,
        "text": "The zone path used to provision the container.",
        "provisioning": True,
    },
    {
        "section": "container",
        "keyword": "detach",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "default": True,
        "convert": "boolean",
        "text": "Run container in background. Set to ``false`` only for init containers, alongside :kw:`start_timeout` and the :c-tag:`nostatus` tag.",
    },
    {
        "sections": ["task", "container"],
        "keyword": "entrypoint",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "text": "The script or binary executed in the container. Args must be set in :kw:`command`.",
        "example": "/bin/sh"
    },
    {
        "sections": ["task", "container"],
        "keyword": "rm",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "default": False,
        "convert": "boolean",
        "text": "If set to ``true``, add :opt:`--rm` to the docker run args and make sure the instance is removed on resource stop.",
        "example": False
    },
    {
        "sections": ["task", "container"],
        "keyword": "volume_mounts",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "shlex",
        "default": [],
        "text": "The whitespace separated list of ``<volume name|local dir>:<containerized mount path>:<mount options>``. "
                "When the source is a local dir, the default <mount option> is rw. "
                "When the source is a volume name, the default <mount option> is taken from volume access.",
        "example": "myvol1:/vol1 myvol2:/vol2:rw /localdir:/data:ro"
    },
    {
        "sections": ["task", "container"],
        "keyword": "environment",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "shlex",
        "default": [],
        "text": "The whitespace separated list of ``<var>=<value>``. A shell expression spliter is applied, so double quotes can be around values only or whole ``<var>=<value>``. Variables are uppercased.",
        "example": """AA="a a" "BB=c c" CC=d """
    },
    {
        "section": "container",
        "keyword": "secrets_environment",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "shlex",
        "default": [],
        "text": "A whitespace separated list of ``<var>=<secret name>/<key path>``. A shell expression spliter is applied, so double quotes can be around ``<secret name>/<key path>`` only or whole ``<var>=<secret name>/<key path>``. Variables are uppercased.",
        "example": "CRT=cert1/server.crt PEM=cert1/server.pem"
    },
    {
        "sections": ["task", "app"],
        "keyword": "secrets_environment",
        "at": True,
        "convert": "shlex",
        "default": [],
        "text": "A whitespace separated list of ``<var>=<secret name>/<key path>``. A shell expression spliter is applied, so double quotes can be around ``<secret name>/<key path>`` only or whole ``<var>=<secret name>/<key path>``. Variables are uppercased.",
        "example": "CRT=cert1/server.crt PEM=cert1/server.pem"
    },
    {
        "section": "container",
        "keyword": "configs_environment",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "shlex",
        "default": [],
        "text": "The whitespace separated list of ``<var>=<config name>/<key path>``. A shell expression spliter is applied, so double quotes can be around ``<config name>/<key path>`` only or whole ``<var>=<config name>/<key path>``. Variables are uppercased.",
        "example": "CRT=cert1/server.crt PEM=cert1/server.pem"
    },
    {
        "sections": ["task", "app"],
        "keyword": "configs_environment",
        "at": True,
        "convert": "shlex",
        "default": [],
        "text": "The whitespace separated list of ``<var>=<config name>/<key path>``. A shell expression spliter is applied, so double quotes can be around ``<config name>/<key path>`` only or whole ``<var>=<config name>/<key path>``. Variables are uppercased.",
        "example": "CRT=cert1/server.crt PEM=cert1/server.pem"
    },
    {
        "sections": ["task", "app"],
        "keyword": "environment",
        "at": True,
        "convert": "shlex",
        "default": [],
        "text": "The whitespace separated list of ``<var>=<config name>/<key path>``. A shell expression spliter is applied, so double quotes can be around ``<config name>/<key path>`` only or whole ``<var>=<config name>/<key path>``. Variables are uppercased.",
        "example": "CRT=cert1/server.crt PEM=cert1/server.pem"
    },
    {
        "sections": ["task", "container"],
        "keyword": "devices",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "shlex",
        "default": [],
        "text": "The whitespace separated list of ``<host devpath>:<containerized devpath>``, specifying the host devices the container should have access to.",
        "example": "myvol1:/dev/xvda myvol2:/dev/xvdb"
    },
    {
        "sections": ["task", "container"],
        "keyword": "netns",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "text": "Sets the :cmd:`docker run --net` argument. The default is ``none`` if :opt:`--net` is not specified in :kw:`run_args`, meaning the container will have a private netns other containers can share. A :c-res:`ip.netns` or :c-res:`ip.cni` resource can configure an ip address in this container. A container with ``netns=container#0`` will share the container#0 netns. In this case agent format a :opt:`--net=container:<name of container#0 docker instance>`. ``netns=host`` shares the host netns.",
        "example": "container#0"
    },
    {
        "sections": ["task", "container"],
        "keyword": "userns",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "candidates": ("host", None),
        "text": "Sets the :cmd:`docker run --userns` argument. If not set, the container will have a private userns other containers can share. A container with ``userns=host`` will share the host's userns.",
        "example": "container#0"
    },
    {
        "sections": ["task", "container"],
        "keyword": "pidns",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "text": "Sets the :cmd:`docker run --pid` argument. If not set, the container will have a private pidns other containers can share. Usually a pidns sharer will run a google/pause image to reap zombies. A container with ``pidns=container#0`` will share the container#0 pidns. In this case agent format a :opt:`--pid=container:<name of container#0 docker instance>`. Use ``pidns=host`` to share the host's pidns.",
        "example": "container#0"
    },
    {
        "sections": ["task", "container"],
        "keyword": "ipcns",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "text": "Sets the :cmd:`docker run --ipc` argument. If not set, the docker daemon's default value is used. ``ipcns=none`` does not mount /dev/shm. ``ipcns=private`` creates a ipcns other containers can not share. ``ipcns=shareable`` creates a netns other containers can share. ``ipcns=container#0`` will share the container#0 ipcns.",
        "example": "container#0"
    },
    {
        "sections": ["task", "container"],
        "keyword": "utsns",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "candidates": (None, "host"),
        "text": "Sets the :cmd:`docker run --uts` argument. If not set, the container will have a private utsns. A container with ``utsns=host`` will share the host's hostname.",
        "example": "container#0"
    },
    {
        "sections": ["task", "container"],
        "keyword": "privileged",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "tristate",
        "text": "Give extended privileges to the container.",
        "example": "container#0"
    },
    {
        "sections": ["task", "container"],
        "keyword": "interactive",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "tristate",
        "text": "Keep stdin open even if not attached. To use if the container entrypoint is a shell.",
    },
    {
        "sections": ["task", "container"],
        "keyword": "tty",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "tristate",
        "text": "Allocate a pseudo-tty.",
    },
    {
        "sections": ["task", "container"],
        "keyword": "name",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "default_text": "<autogenerated>",
        "text": "The name to assign to the container on docker run. If none is specified a ``<namespace>..<name>.container.<rid idx>`` name is automatically assigned.",
        "example": "osvcprd..rundeck.container.db"
    },
    {
        "sections": ["task", "container"],
        "keyword": "image",
        "at": True,
        "required": True,
        "rtype": ["oci", "docker", "podman"],
        "text": "The docker image pull, and run the container with.",
        "example": "83f2a3dd2980 or ubuntu:latest"
    },
    {
        "sections": ["task", "container"],
        "keyword": "image_pull_policy",
        "at": True,
        "required": False,
        "default": "once",
        "rtype": ["oci", "docker", "podman"],
        "candidates": ["once", "always"],
        "text": "The docker image pull policy. ``always`` pull upon each container start, ``once`` pull if not already pulled (default).",
        "example": "once"
    },
    {
        "sections": ["task", "container"],
        "keyword": "command",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "shlex",
        "text": "The command to execute in the docker container on run.",
        "example": "/opt/tomcat/bin/catalina.sh"
    },
    {
        "sections": ["task", "container"],
        "keyword": "run_args",
        "at": True,
        "rtype": ["oci", "docker", "podman"],
        "convert": "expanded_shlex",
        "text": "Extra arguments to pass to the docker run command, like volume and port mappings.",
        "example": "-v /opt/docker.opensvc.com/vol1:/vol1:rw -p 37.59.71.25:8080:8080"
    },
    {
        "section": "container",
        "keyword": "virtinst",
        "rtype": ["kvm", "xen", "ovm"],
        "text": "The :cmd:`virt-install` command to use to create the container.",
        "convert": "shlex",
        "required": True,
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "snap",
        "rtype": ["kvm", "xen", "ovm", "zone", "esx"],
        "text": "The target snapshot/clone full path containing the new container disk files.",
        "required": False,
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "snapof",
        "rtype": ["kvm", "xen", "ovm", "zone", "esx"],
        "text": "The snapshot origin full path containing the reference container disk files.",
        "required": False,
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "container_origin",
        "rtype": "zone",
        "text": "The origin container having the reference container disk files.",
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "jailroot",
        "rtype": "jail",
        "text": "Sets the root fs directory of the container",
        "required": True,
    },
    {
        "section": "container",
        "keyword": "launch_image",
        "at": True,
        "required": True,
        "rtype": "lxd",
        "provisioning": True,
        "text": "The lxd image to instantiate on provision.",
        "example": "ubuntu:16.04"
    },
    {
        "section": "container",
        "keyword": "launch_options",
        "at": True,
        "rtype": "lxd",
        "provisioning": True,
        "convert": "shlex",
        "default": [],
        "default_text": "",
        "text": "The :cmd:`lxc launch <image> ... <name>` options set on provision.",
        "example": "-p default"
    },
    {
        "section": "container",
        "keyword": "cf",
        "rtype": "lxc",
        "text": "Defines a lxc configuration file in a non-standard location.",
        "provisioning": True,
        "example": "/srv/mycontainer/config"
    },
    {
        "section": "container",
        "keyword": "rootfs",
        "rtype": ["lxc", "vz", "zone"],
        "text": "Sets the root fs directory of the container",
        "required": False,
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "template",
        "rtype": ["vz", "zone"],
        "text": "Sets the url of the template unpacked into the container root fs.",
        "required": True,
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "template",
        "rtype": ["lxc"],
        "text": "Sets the url of the template unpacked into the container root fs or the name of the template passed to :cmd:`lxc-create`.",
        "required": True,
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "template_options",
        "rtype": ["lxc"],
        "text": "The arguments to pass through :cmd:`lxc-create` to the per-template script.",
        "convert": "shlex",
        "default": [],
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "mirror",
        "rtype": ["lxc"],
        "text": "Sets the ``MIRROR`` environment variable for :cmd:`lxc-create`, pointing the distribution server to use.",
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "security_mirror",
        "rtype": ["lxc"],
        "text": "Sets the ``SECURITY_MIRROR`` environment variable for :cmd:`lxc-create`, pointing the security distribution server to use. If not set but mirror is set, use mirror as the security mirror.",
        "provisioning": True
    },
    {
        "section": "container",
        "keyword": "name",
        "at": True,
        "rtype": list(set(rcEnv.vt_supported)-set(["oci", "docker", "podman"])),
        "default_text": "the service name",
        "text": "Set if the container hostname is different from the container name."
    },
    {
        "sections": ["task", "container"],
        "keyword": "hostname",
        "at": True,
        "rtype": rcEnv.vt_supported,
        "text": "This need to be set if the virtual machine hostname is different from the machine name."
    },
    {
        "section": "container",
        "keyword": "rcmd",
        "convert": "shlex",
        "at": True,
        "rtype": "lxc",
        "example": "lxc-attach -e -n osvtavnprov01 -- ",
        "text": "An container remote command override the agent default"
    },
    {
        "section": "container",
        "keyword": "vapp",
        "rtype": "vcloud",
        "required": True,
        "at": True,
        "example": "MyVapp",
        "text": "The Vcloud Virtual App hosting the VM."
    },
    {
        "section": "container",
        "keyword": "osvc_root_path",
        "at": True,
        "rtype": rcEnv.vt_supported,
        "example": "/opt/opensvc",
        "text": "If the OpenSVC agent is installed via package in the container, this parameter must not be set. Else the value can be set to the fullpath hosting the agent installed from sources."
    },
    {
        "section": "container",
        "keyword": "guestos",
        "at": True,
        "rtype": rcEnv.vt_supported,
        "candidates": ["unix", "windows"],
        "text": "The operating system in the virtual machine."
    },
    {
        "section": "container",
        "keyword": "ips",
        "convert": "list",
        "at": True,
        "rtype": "jail",
        "text": "The ipv4 addresses of the jail."
    },
    {
        "section": "container",
        "keyword": "ip6s",
        "convert": "list",
        "at": True,
        "rtype": "jail",
        "text": "The ipv6 addresses of the jail."
    },
    {
        "section": "container",
        "keyword": "shared_ip_group",
        "at": True,
        "rtype": rcEnv.vt_cloud,
        "text": "The cloud shared ip group name to allocate a public ip from."
    },
    {
        "section": "container",
        "keyword": "size",
        "at": True,
        "rtype": rcEnv.vt_cloud,
        "text": "The cloud vm size, as known to the cloud manager.",
        "example": "tiny"
    },
    {
        "section": "container",
        "keyword": "key_name",
        "at": True,
        "required": True,
        "rtype": rcEnv.vt_cloud,
        "text": "The key name, as known to the cloud manager, to trust in the provisioned vm."
    },
    {
        "section": "container",
        "keyword": "prm_cores",
        "rtype": "srp",
        "default": 1,
        "convert": "integer",
        "provisioning": True,
        "text": "The number of core to bind the SRP container to."
    },
    {
        "section": "container",
        "keyword": "ip",
        "at": True,
        "rtype": "srp",
        "provisioning": True,
        "text": "The ip name or addr used to create the SRP container."
    },
    {
        "section": "container",
        "keyword": "rootpath",
        "at": True,
        "rtype": "srp",
        "provisioning": True,
        "text": "The path of the SRP container root filesystem."
    },
    {
        "section": "container",
        "keyword": "cloud_id",
        "required": True,
        "at": True,
        "rtype": rcEnv.vt_cloud,
        "text": "The cloud id as configured in ``node.conf``.",
        "example": "cloud#1"
    },
    {
        "section": "container",
        "keyword": "uuid",
        "at": True,
        "required": True,
        "rtype": "ovm",
        "text": "The virtual machine unique identifier used to pass commands on the VM."
    },
    {
        "section": "DEFAULT",
        "keyword": "hard_affinity",
        "inheritance": "head",
        "convert": "set",
        "default": set(),
        "at": True,
        "text": "A whitespace separated list of services that must be started on the node to allow the monitor to start this service.",
        "example": "svc1 svc2"
    },
    {
        "section": "DEFAULT",
        "keyword": "hard_anti_affinity",
        "inheritance": "head",
        "convert": "set",
        "default": set(),
        "at": True,
        "text": "A whitespace separated list of services that must not be started on the node to allow the monitor to start this service.",
        "example": "svc1 svc2"
    },
    {
        "section": "DEFAULT",
        "keyword": "soft_affinity",
        "inheritance": "head",
        "convert": "set",
        "default": set(),
        "at": True,
        "text": "A whitespace separated list of services that must be started on the node to allow the monitor to start this service. If the local node is the only candidate ignore this constraint and allow start.",
        "example": "svc1 svc2"
    },
    {
        "section": "DEFAULT",
        "keyword": "soft_anti_affinity",
        "inheritance": "head",
        "convert": "set",
        "default": set(),
        "at": True,
        "text": "A whitespace separated list of services that must not be started on the node to allow the monitor to start this service. If the local node is the only candidate ignore this constraint and allow start.",
        "example": "svc1 svc2"
    },
    {
        "section": "DEFAULT",
        "keyword": "prkey",
        "at": True,
        "text": "Defines a specific default persistent reservation key for the service. A prkey set in a resource takes priority. If no prkey is specified in the service nor in the ``DEFAULT`` section, the prkey in ``node.conf`` is used. If ``node.conf`` has no prkey set, the hostid is computed and written in ``node.conf``."
    },
    {
        "section": "DEFAULT",
        "keyword": "no_preempt_abort",
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "If set to ``true``, OpenSVC will preempt scsi reservation with a preempt command instead of a preempt and and abort. Some scsi target implementations do not support this last mode (esx). If set to ``false`` or not set, :kw:`no_preempt_abort` can be activated on a per-resource basis."
    },
    {
        "section": "DEFAULT",
        "keyword": "show_disabled",
        "inheritance": "head",
        "at": True,
        "default": True,
        "convert": "boolean",
        "candidates": [True, False],
        "text": "Specifies if the disabled resources must be included in the print status and json status output."
    },
    {
        "section": "DEFAULT",
        "keyword": "topology",
        "inheritance": "head",
        "at": True,
        "default": "failover",
        "candidates": ["failover", "flex"],
        "text": "``failover`` the service is allowed to be up on one node at a time. ``flex`` the service can be up on :kw:`flex_target` nodes, where :kw:`flex_target` must be in the [flex_min, flex_max] range."
    },
    {
        "section": "DEFAULT",
        "keyword": "scale",
        "inheritance": "head",
        "at": True,
        "convert": "integer",
        "text": "If set, create and provision the necessary slave services, named ``<n>.<name>``, to meet the target ``<scale>`` number of started instances.",
        "example": "4"
    },
    {
        "section": "DEFAULT",
        "keyword": "scaler_slave",
        "inheritance": "head",
        "convert": "boolean",
        "default": False,
        "at": True,
        "text": "Automatically set to ``true`` by the daemon monitor when creating new scaler slaves."
    },
    {
        "section": "DEFAULT",
        "keyword": "orchestrate",
        "inheritance": "head",
        "at": True,
        "default": "no",
        "convert": "string",
        "candidates": ("ha", "start", "no"),
        "text": "If set to ``no``, disable service orchestration by the OpenSVC daemon monitor, including service start on boot. If set to ``start`` failover services won't failover automatically, though the service instance on the natural placement leader is started if another instance is not already up. Flex services won't restart the :kw:`flex_target` number of up instances. Resource restart is still active whatever the :kw:`orchestrate` value.",
    },
    {
        "section": "DEFAULT",
        "keyword": "stonith",
        "inheritance": "head",
        "convert": "boolean",
        "default": False,
        "candidates": (True, False),
        "depends": [("topology", ["failover"])],
        "text": "Stonith the node previously running the service if stale upon start by the daemon monitor.",
    },
    {
        "section": "DEFAULT",
        "keyword": "placement",
        "inheritance": "head",
        "default": "nodes order",
        "candidates": ["none", "nodes order", "load avg", "shift", "spread", "score"],
        "text": "Set a service instances placement policy:\n\n"
                       "* ``none`` no placement policy. a policy for dummy, observe-only, services.\n"
                       "* ``nodes order`` the left-most available node is allowed to start a service instance when necessary.\n"
                       "* ``load avg`` the least loaded node takes precedences.\n"
                       "* ``shift`` shift the nodes order ranking by the service prefix converter to an integer.\n"
                       "* ``spread`` a spread policy tends to perfect leveling with many services.\n"
                       "* ``score`` the highest scoring node takes precedence (the score is a composite indice of load, mem and swap).\n",
    },
    {
        "section": "DEFAULT",
        "keyword": "constraints",
        "inheritance": "head",
        "at": True,
        "depends": [("orchestrate", "ha")],
        "example": "$(\"{nodename}\"==\"n2.opensvc.com\")",
        "text": "An expression evaluating as a boolean, constraining the service instance placement by the daemon monitor to nodes with the constraints evaluated as True.\n\nThe constraints are not honored by manual start operations. The constraints value is embedded in the json status.\n\nSupported comparison operators are ``==``, ``!=``, ``>``, ``>=``, ``<=``, ``in (e1, e2)``, ``in [e1, e2]``.\n\nSupported arithmetic operators are ``*``, ``+``, ``-``, ``/``, ``**``, ``//``, ``%``.\n\nSupported binary operators are ``&``, ``|``, ``^``.\n\nThe negation operator is ``not``.\n\nSupported boolean operators are ``and``, ``or``.\n\nReferences are allowed.\n\nStrings, and references evaluating as strings, containing dots must be quoted.",
    },
    {
        "section": "DEFAULT",
        "keyword": "flex_min",
        "inheritance": "head",
        "default": 1,
        "convert": "integer",
        "depends": [("topology", ["flex"])],
        "text": "Minimum number of up instances in the cluster. Below this number the aggregated service status is degraded to warn.."
    },
    {
        "section": "DEFAULT",
        "keyword": "flex_max",
        "inheritance": "head",
        "default_text": "<number of svc nodes>",
        "convert": "integer",
        "depends": [("topology", ["flex"])],
        "text": "Maximum number of up instances in the cluster. Above this number the aggregated service status is degraded to warn. ``0`` means unlimited."
    },
    {
        "section": "DEFAULT",
        "keyword": "flex_target",
        "inheritance": "head",
        "default_text": "<the value of flex_min>",
        "convert": "integer",
        "depends": [("topology", ["flex"])],
        "text": "Optimal number of up instances in the cluster. The value must be between :kw:`flex_min` and :kw:`flex_max`. If ``orchestrate=ha``, the monitor ensures the :kw:`flex_target` is met."
    },
    {
        "section": "DEFAULT",
        "keyword": "flex_cpu_low_threshold",
        "inheritance": "head",
        "default": 0,
        "convert": "integer",
        "depends": [("topology", ["flex"])],
        "text": "Cluster-wide load average below which flex service instances will be stopped.",
    },
    {
        "section": "DEFAULT",
        "keyword": "flex_cpu_high_threshold",
        "inheritance": "head",
        "default": 100,
        "convert": "integer",
        "depends": [("topology", ["flex"])],
        "text": "Cluster-wide load average above which flex new service instances will be started.",
    },
    {
        "section": "DEFAULT",
        "keyword": "env",
        "inheritance": "head",
        "default_text": "<same as node env>",
        "candidates": rcEnv.allowed_svc_envs,
        "text": "A non-PRD service can not be brought up on a PRD node, but a PRD service can be startup on a non-PRD node (in a DRP situation). The default value is the node :kw:`env`."
    },
    {
        "section": "DEFAULT",
        "keyword": "parents",
        "inheritance": "head",
        "at": True,
        "default": [],
        "default_text": "",
        "convert": "list_lower",
        "text": "List of services or instances expressed as ``<path>[@<nodename>]`` that must be ``avail up`` before allowing this service to be started by the daemon monitor. Whitespace separated."
    },
    {
        "section": "DEFAULT",
        "keyword": "children",
        "inheritance": "head",
        "at": True,
        "default": [],
        "default_text": "",
        "convert": "list_lower",
        "text": "List of services that must be ``avail down`` before allowing this service to be stopped by the daemon monitor. Whitespace separated."
    },
    {
        "section": "DEFAULT",
        "keyword": "slaves",
        "inheritance": "head",
        "at": True,
        "default": [],
        "convert": "list",
        "text": "List of services to propagate the :c-action:`start` and :c-action:`stop` actions to."
    },
    {
        "section": "DEFAULT",
        "keyword": "nodes",
        "inheritance": "head",
        "at": True,
        "convert": "nodes_selector",
        "default": rcEnv.nodename,
        "default_text": "<hostname of the current node>",
        "text": "A node selector expression specifying the list of cluster nodes hosting service instances."
    },
    {
        "section": "DEFAULT",
        "keyword": "drpnode",
        "inheritance": "head",
        "convert": "lower",
        "default": "",
        "at": True,
        "text": "The backup node where the service is activated in a DRP situation. This node is also a data synchronization target for :c-res:`sync` resources.",
        "example": "node1"
    },
    {
        "section": "DEFAULT",
        "keyword": "drpnodes",
        "inheritance": "head",
        "at": True,
        "convert": "list_lower",
        "default": [],
        "default_text": "",
        "text": "Alternate backup nodes, where the service could be activated in a DRP situation if the 'drpnode' is not available. These nodes are also data synchronization targets for :c-res:`sync` resources.",
        "example": "node1 node2"
    },
    {
        "section": "DEFAULT",
        "keyword": "encapnodes",
        "inheritance": "head",
        "convert": "list_lower",
        "default": [],
        "default_text": "",
        "text": "The list of `containers` handled by this service and with an OpenSVC agent installed to handle the encapsulated resources. With this parameter set, parameters can be scoped with the ``@encapnodes`` suffix.",
        "example": "vm1 vm2"
    },
    {
        "section": "DEFAULT",
        "keyword": "app",
        "default": "default",
        "text": "Used to identify who is responsible for this service, who is billable and provides a most useful filtering key. Better keep it a short code."
    },
    {
        "section": "DEFAULT",
        "keyword": "scsireserv",
        "at": True,
        "default": False,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "If set to ``true``, OpenSVC will try to acquire a type-5 (write exclusive, registrant only) scsi3 persistent reservation on every path to disks of every disk group attached to this service. Existing reservations are preempted to not block service start-up. If the start-up was not legitimate the data are still protected from being written over from both nodes. If set to ``false`` or not set, :kw:`scsireserv` can be activated on a per-resource basis."
    },
    {
        "section": "DEFAULT",
        "keyword": "bwlimit",
        "convert": "speed_kps",
        "text": "Bandwidth limit in KB applied to all rsync transfers. Leave empty to enforce no limit.",
        "example": "3 mb/s"
    },
    {
        "section": "DEFAULT",
        "keyword": "sync_interval",
        "default": 121,
        "convert": "duration",
        "text": "Set the minimum delay between syncs in minutes. If a sync is triggered through a scheduler or manually, it is skipped if last sync occurred less than :kw:`sync_min_delay` ago. The mecanism is enforced by a timestamp created upon each sync completion in ``<pathvar>/services/<namespace>/<kind>/<name>/<rid>/last_sync_<node>``"
    },
    {
        "section": "DEFAULT",
        "keyword": "sync_max_delay",
        "default": "1d",
        "convert": "duration_minute",
        "text": "Unit is minutes. This sets to delay above which the sync status of the resource is to be considered down. Should be set according to your application service level agreement. The scheduler task frequency should be set between :kw:`sync_min_delay` and :kw:`sync_max_delay`."
    },
    {
        "section": "DEFAULT",
        "keyword": "presnap_trigger",
        "convert": "shlex",
        "text": "Define a command to run before creating snapshots. This is most likely what you need to use plug a script to put you data in a coherent state (alter begin backup and the like).",
        "example": "/srv/svc1/etc/init.d/pre_snap.sh"
    },
    {
        "section": "DEFAULT",
        "keyword": "postsnap_trigger",
        "convert": "shlex",
        "text": "Define a command to run after snapshots are created. This is most likely what you need to use plug a script to undo the actions of :kw:`presnap_trigger`.",
        "example": "/srv/svc1/etc/init.d/post_snap.sh"
    },
    {
        "section": "DEFAULT",
        "keyword": "monitor_action",
        "at": True,
        "candidates": ("reboot", "crash", "freezestop", "switch"),
        "text": "The action to take when a monitored resource is not up nor standby up, and if the resource restart procedure has failed.",
        "example": "reboot"
    },
    {
        "section": "DEFAULT",
        "keyword": "pre_monitor_action",
        "at": True,
        "text": "A script to execute before the :kw:`monitor_action`. For example, if the :kw:`monitor_action` is set to ``freezestop``, the script can decide to crash the server if it detects a situation were the freezestop can not succeed (ex. fs can not be umounted with a dead storage array).",
        "example": "/bin/true"
    },
    {
        "section": "DEFAULT",
        "keyword": "create_pg",
        "default": True,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "Use process containers when possible. Containers allow capping memory, swap and cpu usage per service. Lxc containers are naturally containerized, so skip containerization of their startapp."
    },
    {
        "section": "app",
        "keyword": "type",
        "inheritance": "leaf",
        "candidates": ("simple", "forking", "winservice"),
        "default": "forking",
        "text": "The app driver to use. ``simple`` for foreground-running apps. ``forking`` for daemonizing apps."
    },
    {
        "section": "app",
        "keyword": "name",
        "rtype": "winservice",
        "at": True,
        "text": "The name of the Windows service."
    },
    {
        "section": "app",
        "keyword": "kill",
        "rtype": "simple",
        "candidates": ["parent", "tree"],
        "default": "parent",
        "at": True,
        "text": "Select a process kill strategy to use on resource stop. ``parent`` kill only the parent process forked by the agent. ``tree`` also kill its children."
    },
    {
        "section": "app",
        "keyword": "script",
        "rtype": ["forking", "simple"],
        "at": True,
        "required": False,
        "text": "Full path to the app launcher script. Or its basename if the file is hosted in the ``<pathetc>/<namespace>/<kind>/<name>.d/`` path. This script must accept as arg0 the activated actions word: ``start`` for start, ``stop`` for stop, ``status`` for check, ``info`` for info."
    },
    {
        "section": "app",
        "keyword": "status_log",
        "rtype": ["forking", "simple"],
        "at": True,
        "required": False,
        "default": False,
        "convert": "boolean",
        "text": "Redirect the checker script stdout to the resource status info-log, and stderr to warn-log. The default is ``false``, for it is common the checker scripts outputs are not tuned for opensvc."
    },
    {
        "section": "app",
        "keyword": "timeout",
        "rtype": ["forking", "simple", "winservice"],
        "convert": "duration",
        "at": True,
        "text": "Wait for <duration> before declaring the app launcher action a failure. Can be overriden by :kw:`<action>_timeout`. If no timeout is set, the agent waits indefinitely for the app launcher to return. A timeout can be coupled with :kw:`optional=true` to not abort a service instance action when an app launcher did not return.",
        "example": "180"
    },
    {
        "section": "app",
        "keyword": "start_timeout",
        "rtype": ["forking", "simple", "winservice"],
        "convert": "duration",
        "at": True,
        "text": "Wait for <duration> before declaring the app launcher start action a failure. Takes precedence over :kw:`timeout`. If neither :kw:`timeout` nor :kw:`start_timeout` is set, the agent waits indefinitely for the app launcher to return. A timeout can be coupled with :kw:`optional=true` to not abort a service instance start when an app launcher did not return.",
        "example": "180"
    },
    {
        "section": "app",
        "keyword": "stop_timeout",
        "rtype": ["forking", "simple", "winservice"],
        "convert": "duration",
        "at": True,
        "text": "Wait for <duration> before declaring the app launcher stop action a failure. Takes precedence over :kw:`timeout`. If neither :kw:`timeout` nor :kw:`stop_timeout` is set, the agent waits indefinitely for the app launcher to return. A timeout can be coupled with :kw:`optional=true` to not abort a service instance stop when an app launcher did not return.",
        "example": "180"
    },
    {
        "section": "app",
        "keyword": "check_timeout",
        "rtype": ["forking", "simple"],
        "convert": "duration",
        "at": True,
        "text": "Wait for <duration> before declaring the app launcher check action a failure. Takes precedence over :kw:`timeout`. If neither :kw:`timeout` nor :kw:`check_timeout` is set, the agent waits indefinitely for the app launcher to return. A timeout can be coupled with :kw:`optional=true` to not abort a service instance check when an app launcher did not return.",
        "example": "180"
    },
    {
        "section": "app",
        "keyword": "info_timeout",
        "rtype": ["forking", "simple"],
        "convert": "duration",
        "at": True,
        "text": "Wait for <duration> before declaring the app launcher info action a failure. Takes precedence over :kw:`timeout`. If neither :kw:`timeout` nor :kw:`info_timeout` is set, the agent waits indefinitely for the app launcher to return. A timeout can be coupled with :kw:`optional=true` to not abort a service instance info when an app launcher did not return.",
        "example": "180"
    },
    {
        "section": "app",
        "keyword": "start",
        "rtype": ["forking", "simple"],
        "at": True,
        "default": False,
        "text": "``true`` execute :cmd:`<script> start` on start action. ``false`` do nothing on start action. ``<shlex expression>`` execute the command on start.",
    },
    {
        "section": "app",
        "keyword": "stop",
        "rtype": ["forking", "simple"],
        "at": True,
        "default": False,
        "text": "``true`` execute :cmd:`<script> stop` on stop action. ``false`` do nothing on stop action. ``<shlex expression>`` execute the command on stop action.",
    },
    {
        "section": "app",
        "keyword": "check",
        "rtype": ["forking", "simple"],
        "at": True,
        "default": False,
        "text": "``true`` execute :cmd:`<script> status` on status evaluation. ``false`` do nothing on status evaluation. ``<shlex expression>`` execute the command on status evaluation.",
    },
    {
        "section": "app",
        "keyword": "info",
        "rtype": ["forking", "simple"],
        "at": True,
        "default": False,
        "text": "``true`` execute :cmd:`<script> info` on info action. ``false`` do nothing on info action. ``<shlex expression>`` execute the command on info action.",
    },
    {
        "section": "app",
        "keyword": "limit_as",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_cpu",
        "rtype": ["forking", "simple"],
        "convert": "duration",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_core",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_data",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_fsize",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_memlock",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_nofile",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_nproc",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_rss",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_stack",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "limit_vmem",
        "rtype": ["forking", "simple"],
        "convert": "size",
        "at": True,
        "text": ""
    },
    {
        "section": "app",
        "keyword": "user",
        "rtype": ["forking", "simple"],
        "at": True,
        "text": "If the binary is owned by the root user, run it as the specified user instead of root."
    },
    {
        "section": "app",
        "keyword": "group",
        "rtype": ["forking", "simple"],
        "at": True,
        "text": "If the binary is owned by the root user, run it as the specified group instead of root."
    },
    {
        "section": "app",
        "keyword": "cwd",
        "rtype": ["forking", "simple"],
        "at": True,
        "text": "Change the working directory to the specified location instead of the default ``<pathtmp>``."
    },
    {
        "section": "sync",
        "keyword": "type",
        "inheritance": "leaf",
        "candidates": ["rsync", "oci", "docker", "dds", "netapp", "symsrdfs", "zfs", "btrfs", "symclone", "symsnap", "hp3par", "hp3parsnap", "evasnap", "ibmdssnap", "necismsnap", "zfssnap", "btrfssnap", "rados", "s3"],
        "default": "rsync",
        "text": "Point a sync driver to use."
    },
    {
        "section": "sync",
        "keyword": "target",
        "convert": "list",
        "rtype": ["oci", "docker", "podman"],
        "at": True,
        "required": True,
        "candidates": ["nodes", "drpnodes"],
        "text": "Destination nodes of the sync."
    },
    {
        "section": "sync",
        "keyword": "snar",
        "rtype": "s3",
        "at": True,
        "example": "/srv/mysvc/var/sync.1.snar",
        "text": "The GNU tar snar file full path. The snar file stored the GNU tar metadata needed to do an incremental tarball. If the service fails over shared disks the snar file should be stored there, so the failover node can continue the incremental cycle."
    },
    {
        "section": "sync",
        "keyword": "src",
        "convert": "list",
        "rtype": "s3",
        "at": True,
        "required": True,
        "example": "/srv/mysvc/tools /srv/mysvc/apps*",
        "text": "Source globs as passed as paths to archive to a tar command."
    },
    {
        "section": "sync",
        "keyword": "options",
        "convert": "shlex",
        "rtype": "s3",
        "at": True,
        "example": "--exclude *.pyc",
        "text": "Options passed to GNU tar for archiving."
    },
    {
        "section": "sync",
        "keyword": "bucket",
        "rtype": "s3",
        "at": True,
        "required": True,
        "example": "opensvc-myapp",
        "text": "The name of the S3 bucket to upload the backup to."
    },
    {
        "section": "sync",
        "keyword": "full_schedule",
        "rtype": "s3",
        "at": True,
        "example": "@1441 sun",
        "text": "The schedule of full backups. :c-action:`sync_update` actions are triggered according to the resource :kw:`schedule` parameter, and do a full backup if the current date matches the :kw:`full_schedule` parameter or an incremental backup otherwise."
    },
    {
        "section": "sync",
        "keyword": "recursive",
        "rtype": "zfssnap",
        "at": True,
        "example": "true",
        "default": True,
        "convert": "boolean",
        "text": "Set to true to snap recursively the datasets."
    },
    {
        "section": "sync",
        "keyword": "name",
        "rtype": "zfssnap",
        "at": True,
        "example": "weekly",
        "text": "A name included in the snapshot name to avoid retention conflicts between multiple zfs snapshot resources. A full snapshot name is formatted as ``<subvol>.<name>.snap.<datetime>``. Example: data.weekly.snap.2016-03-09.10:09:52"
    },
    {
        "section": "sync",
        "keyword": "dataset",
        "convert": "list",
        "rtype": "zfssnap",
        "at": True,
        "required": True,
        "example": "svc1fs/data svc1fs/log",
        "text": "A whitespace separated list of datasets to snapshot."
    },
    {
        "section": "sync",
        "keyword": "keep",
        "rtype": "zfssnap",
        "at": True,
        "default": 3,
        "convert": "integer",
        "example": "3",
        "text": "The maximum number of snapshots to retain."
    },
    {
        "section": "sync",
        "keyword": "name",
        "rtype": "btrfssnap",
        "at": True,
        "example": "weekly",
        "text": "A name included in the snapshot name to avoid retention conflicts between multiple btrfs snapshot resources. A full snapshot name is formatted as ``<subvol>.<name>.snap.<datetime>``. Example: data.weekly.snap.2016-03-09.10:09:52"
    },
    {
        "section": "sync",
        "keyword": "subvol",
        "convert": "list",
        "rtype": "btrfssnap",
        "at": True,
        "required": True,
        "example": "svc1fs:data svc1fs:log",
        "text": "A whitespace separated list of ``<label>:<subvol>`` to snapshot."
    },
    {
        "section": "sync",
        "keyword": "keep",
        "rtype": "btrfssnap",
        "at": True,
        "default": 3,
        "convert": "integer",
        "example": "3",
        "text": "The maximum number of snapshots to retain."
    },
    {
        "section": "sync",
        "keyword": "src",
        "convert": "list",
        "rtype": "btrfs",
        "at": True,
        "required": True,
        "text": "Source subvolume of the sync."
    },
    {
        "section": "sync",
        "keyword": "dst",
        "rtype": "btrfs",
        "at": True,
        "required": True,
        "text": "Destination subvolume of the sync."
    },
    {
        "section": "sync",
        "keyword": "target",
        "convert": "list",
        "rtype": "btrfs",
        "at": True,
        "required": True,
        "candidates": ["nodes", "drpnodes"],
        "text": "Destination nodes of the sync."
    },
    {
        "section": "sync",
        "keyword": "recursive",
        "rtype": "btrfs",
        "at": True,
        "default": False,
        "convert": "boolean",
        "candidates": [True, False],
        "text": "Also replicate subvolumes in the src tree."
    },
    {
        "section": "sync",
        "keyword": "src",
        "rtype": "zfs",
        "at": True,
        "required": True,
        "text": "Source dataset of the sync."
    },
    {
        "section": "sync",
        "keyword": "dst",
        "rtype": "zfs",
        "at": True,
        "required": True,
        "text": "Destination dataset of the sync."
    },
    {
        "section": "sync",
        "keyword": "target",
        "convert": "list",
        "rtype": "zfs",
        "required": True,
        "candidates": ['nodes', 'drpnodes', 'local'],
        "text": "Describes which nodes should receive this data sync from the PRD node where the service is up and running. SAN storage shared 'nodes' must not be sync to 'nodes'. SRDF-like paired storage must not be sync to 'drpnodes'."
    },
    {
        "section": "sync",
        "keyword": "recursive",
        "rtype": "zfs",
        "at": True,
        "default": True,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "Describes which nodes should receive this data sync from the PRD node where the service is up and running. SAN storage shared 'nodes' must not be sync to 'nodes'. SRDF-like paired storage must not be sync to 'drpnodes'."
    },
    {
        "section": "sync",
        "keyword": "tags",
        "rtype": "zfs",
        "convert": "set",
        "default": set(),
        "default_text": "",
        "example": "delay_snap",
        "at": True,
        "text": "The zfs sync resource supports the :c-tag:`delay_snap` tag. This tag is used to delay the snapshot creation just before the sync, thus after :kw:`postsnap_trigger` execution. The default behaviour (no tags) is to group all snapshots creation before copying data to remote nodes, thus between :kw:`presnap_trigger` and :kw:`postsnap_trigger`."
    },
    {
        "section": "sync",
        "keyword": "src",
        "convert": "list",
        "rtype": "rsync",
        "at": True,
        "required": True,
        "text": "Source of the sync. Can be a whitespace-separated list of files or dirs passed as-is to rsync. Beware of the meaningful ending '/'. Refer to the rsync man page for details."
    },
    {
        "section": "sync",
        "keyword": "dst",
        "rtype": "rsync",
        "required": True,
        "text": "Destination of the sync. Beware of the meaningful ending '/'. Refer to the rsync man page for details."
    },
    {
        "section": "sync",
        "keyword": "tags",
        "convert": "set",
        "default": set(),
        "default_text": "",
        "example": "delay_snap",
        "at": True,
        "rtype": "rsync",
        "text": "The sync resource supports the :c-tag:`delay_snap` tag. This tag is used to delay the snapshot creation just before the rsync, thus after :kw:`postsnap_trigger` execution. The default behaviour (no tags) is to group all snapshots creation before copying data to remote nodes, thus between :kw:`presnap_trigger` and :kw:`postsnap_trigger`."
    },
    {
        "section": "sync",
        "keyword": "options",
        "convert": "shlex",
        "default": [],
        "default_text": "",
        "example": "--acls --xattrs --exclude foo/bar",
        "at": True,
        "rtype": "rsync",
        "text": "A whitespace-separated list of params passed unchanged to rsync. Typical usage is ACL preservation activation."
    },
    {
        "section": "sync",
        "keyword": "reset_options",
        "convert": "boolean",
        "default": False,
        "at": True,
        "rtype": "rsync",
        "text": "Use options as-is instead of appending options to default hardcoded options. Can be used to disable --xattr or --acls for example."
    },
    {
        "section": "sync",
        "keyword": "target",
        "convert": "list",
        "rtype": "rsync",
        "required": True,
        "candidates": ['nodes', 'drpnodes'],
        "text": "Describes which nodes should receive this data sync from the PRD node where the service is up and running. SAN storage shared 'nodes' must not be sync to 'nodes'. SRDF-like paired storage must not be sync to 'drpnodes'."
    },
    {
        "section": "sync",
        "keyword": "snap",
        "rtype": "rsync",
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "If set to ``true``, OpenSVC will try to snapshot the first snapshottable parent of the source of the sync and try to sync from the snap."
    },
    {
        "section": "sync",
        "keyword": "dstfs",
        "rtype": "rsync",
        "text": "If set to a remote mount point, OpenSVC will verify that the specified mount point is really hosting a mounted FS. This can be used as a safety net to not overflow the parent FS (may be root)."
    },
    {
        "section": "sync",
        "keyword": "bwlimit",
        "convert": "integer",
        "rtype": "rsync",
        "text": "Bandwidth limit in KB applied to this rsync transfer. Leave empty to enforce no limit. Takes precedence over :kw:`bwlimit` set in [DEFAULT]."
    },
    {
        "section": "sync",
        "keyword": "schedule",
        "at": True,
        "text": "Set the this resource synchronization schedule. See ``usr/share/doc/node.conf`` for the schedule syntax reference.",
        "example": '["00:00-01:00@61 mon", "02:00-03:00@61 tue-sun"]'
    },
    {
        "section": "sync",
        "keyword": "sync_max_delay",
        "default": "1d",
        "convert": "duration_minute",
        "text": "Unit is minutes. This sets to delay above which the sync status of the resource is to be considered down. Should be set according to your application service level agreement. The scheduler task frequency should be set between :kw:`sync_min_delay` and :kw:`sync_max_delay`."
    },
    {
        "section": "ip",
        "rtype": [None, "crossbow", "amazon", "gce", "docker", "netns"],
        "keyword": "ipname",
        "required": False,
        "at": True,
        "text": "The DNS name or IP address of the ip resource. Can be different from one node to the other, in which case ``@nodename`` can be specified. This is most useful to specify a different ip when the service starts in DRP mode, where subnets are likely to be different than those of the production datacenter. With the amazon driver, the special ``<allocate>`` value tells the provisioner to assign a new private address."
    },
    {
        "section": "ip",
        "rtype": "cni",
        "keyword": "ipname",
        "required": False,
        "at": True,
        "text": "Not used by the cni driver."
    },
    {
        "section": "ip",
        "keyword": "wait_dns",
        "at": True,
        "convert": "duration",
        "default": 0,
        "example": "10s",
        "text": "Wait for the cluster DNS records associated to the resource to appear after a resource start and before the next resource can be started. This can be used for apps or containers that require the ip or ip name to be resolvable to provision or execute properly."
    },
    {
        "section": "ip",
        "keyword": "dns_name_suffix",
        "at": True,
        "text": "Add the value as a suffix to the DNS record name. The record created is thus formatted as ``<name>-<dns_name_suffix>.<app>.<managed zone>``."
    },
    {
        "section": "ip",
        "keyword": "provisioner",
        "provisioning": True,
        "candidates": ("collector", None),
        "at": True,
        "example": "collector",
        "text": "The IPAM driver to use to provision the ip.",
    },
    {
        "section": "ip",
        "rtype": "cni",
        "keyword": "network",
        "at": True,
        "required": False,
        "default": "default",
        "text": "The name of the CNI network to plug into. The default network is created using the host-local bridge plugin if no existing configuration already exists.",
        "example": "my-weave-net",
    },
    {
        "section": "ip",
        "keyword": "network",
        "at": True,
        "example": "10.0.0.0",
        "text": "The network, in dotted notation, from where the ip provisioner allocates. Also used by the docker ip driver to delete the network route if :kw:`del_net_route` is set to ``true``.",
    },
    {
        "section": "ip",
        "keyword": "dns_update",
        "at": True,
        "default": False,
        "convert": "boolean",
        "candidates": [True, False],
        "text": "Setting this parameter triggers a DNS update. The record created is formatted as ``<name>.<app>.<managed zone>``, unless dns_record_name is specified."
    },
    {
        "section": "ip",
        "keyword": "zone",
        "at": True,
        "text": "The zone name the ip resource is linked to. If set, the ip is plumbed from the global in the zone context.",
        "example": "zone1"
    },
    {
        "section": "ip",
        "rtype": ["docker", "netns"],
        "keyword": "netns",
        "at": True,
        "required": True,
        "text": "The resource id of the container to plumb the ip into.",
        "example": "container#0"
    },
    {
        "section": "ip",
        "rtype": ["docker", "netns"],
        "keyword": "vlan_tag",
        "depends": [("mode", "ovs")],
        "at": True,
        "required": False,
        "text": "The VLAN tag the switch port will relay.",
        "example": "44 45"
    },
    {
        "section": "ip",
        "rtype": ["docker", "netns"],
        "keyword": "vlan_mode",
        "candidates": ["access", "native-tagged", "native-untagged"],
        "depends": [("mode", "ovs")],
        "at": True,
        "required": False,
        "default": "native-untagged",
        "text": "The VLAN port mode.",
        "example": "access"
    },
    {
        "section": "ip",
        "rtype": ["docker", "netns"],
        "keyword": "mode",
        "at": True,
        "required": False,
        "candidates": ["bridge", "dedicated", "macvlan", "ipvlan-l2", "ipvlan-l3", "ovs"],
        "text": "The ip link mode. If ipdev is set to a bridge interface the mode defaults to bridge, else defaults to macvlan. ipvlan requires a 4.2+ kernel.",
        "example": "container#0"
    },
    {
        "section": "ip",
        "keyword": "check_carrier",
        "at": True,
        "required": False,
        "default": True,
        "convert": "boolean",
        "text": "Activate the link carrier check. Set to false if ipdev is a backend "
                "bridge or switch",
    },
    {
        "section": "ip",
        "keyword": "alias",
        "at": True,
        "required": False,
        "default": True,
        "convert": "boolean",
        "text": "Use ip aliasing. Modern ip stack support multiple ip/mask per interface, so :kw:`alias` should be set to false when possible.",
    },
    {
        "section": "ip",
        "keyword": "expose",
        "at": True,
        "required": False,
        "default": [],
        "convert": "list",
        "text": "A whitespace-separated list of ``<port>/<protocol>[:<host port>]`` "
                       "describing socket services that mandate a SRV exposition. With "
                       "<host_port> set, the ip.cni driver configures port mappings too.",
        "example": "443/tcp:8443 53/udp"
    },
    {
        "section": "ip",
        "rtype": "cni",
        "keyword": "netns",
        "at": True,
        "required": False,
        "text": "The resource id of the container to plug into the CNI network.",
        "example": "container#0"
    },
    {
        "section": "ip",
        "rtype": "amazon",
        "keyword": "eip",
        "at": True,
        "text": "The public elastic ip to associate to :kw:`ipname`. The special ``allocate`` value tells the provisioner to assign a new public address.",
        "example": "52.27.90.63"
    },
    {
        "section": "ip",
        "rtype": "amazon",
        "keyword": "cascade_allocation",
        "convert": "list",
        "default": [],
        "provisioning": True,
        "at": True,
        "text": "Set new allocated ip as value to other ip resources :kw:`ipname` parameter. The syntax is a whitespace separated list of ``<rid>.ipname[@<scope>]``.",
        "example": "ip#1.ipname ip#1.ipname@nodes"
    },
    {
        "section": "ip",
        "rtype": "amazon",
        "keyword": "docker_daemon_ip",
        "provisioning": True,
        "at": False,
        "candidates": [True, False],
        "text": "Set new allocated ip as value as a :opt:`--ip <addr>` argument in the :kw:`DEFAULT.docker_daemon_args` parameter.",
        "example": "True"
    },
    {
        "sections": ["disk", "fs"],
        "keyword": "prkey",
        "at": True,
        "text": "Defines a specific persistent reservation key for the resource. Takes priority over the service-level defined prkey and the node.conf specified prkey."
    },
    {
        "section": "disk",
        "rtype": "gce",
        "keyword": "names",
        "convert": "list",
        "at": True,
        "required": True,
        "text": "Set the gce disk names",
        "example": "svc1-disk1"
    },
    {
        "section": "disk",
        "rtype": "gce",
        "keyword": "gce_zone",
        "at": True,
        "required": True,
        "text": "Set the gce zone",
        "example": "europe-west1-b"
    },
    {
        "section": "disk",
        "rtype": "gce",
        "keyword": "description",
        "provisioning": True,
        "at": True,
        "text": "An optional, textual description for the disks being created.",
        "example": "foo"
    },
    {
        "section": "disk",
        "rtype": "gce",
        "keyword": "image",
        "provisioning": True,
        "at": True,
        "text": "An image to apply to the disks being created. When using this option, the size of the disks must be at least as large as the image size.",
        "example": "centos-7"
    },
    {
        "section": "disk",
        "rtype": "gce",
        "keyword": "image_project",
        "provisioning": True,
        "at": True,
        "text": "The project against which all image references will be resolved.",
        "example": "myprj"
    },
    {
        "section": "disk",
        "rtype": ["disk", "gce"],
        "keyword": "size",
        "provisioning": True,
        "at": True,
        "convert": "size",
        "text": "A size expression for the disk allocation.",
        "example": "20g"
    },
    {
        "section": "disk",
        "rtype": "gce",
        "keyword": "source_snapshot",
        "provisioning": True,
        "at": True,
        "text": "A source snapshot used to create the disks. It is safe to delete a snapshot after a disk has been created from the snapshot. In such cases, the disks will no longer reference the deleted snapshot. When using this option, the size of the disks must be at least as large as the snapshot size.",
        "example": "mysrcsnap"
    },
    {
        "section": "disk",
        "rtype": "gce",
        "keyword": "disk_type",
        "provisioning": True,
        "at": True,
        "text": "Specifies the type of disk to create. To get a list of available disk types, run :cmd:`gcloud compute disk-types list`. The default disk type is ``pd-standard``.",
        "example": "pd-standard"
    },
    {
        "section": "ip",
        "rtype": "gce",
        "keyword": "routename",
        "at": True,
        "text": "Set the gce route name",
        "example": "rt-ip1"
    },
    {
        "section": "ip",
        "rtype": "gce",
        "keyword": "gce_zone",
        "at": True,
        "text": "Set the gce ip route next hop zone",
        "example": "europe-west1-b"
    },
    {
        "section": "ip",
        "keyword": "type",
        "inheritance": "leaf",
        "at": True,
        "candidates": [None, "crossbow", "amazon", "gce", "cni", "docker", "netns"],
        "text": "The opensvc ip driver name.",
        "example": "crossbow",
    },
    {
        "section": "ip",
        "rtype": [None, "crossbow", "amazon", "gce", "docker", "netns"],
        "keyword": "ipdev",
        "at": True,
        "required": True,
        "text": "The interface name over which OpenSVC will try to stack the service ip. Can be different from one node to the other, in which case the ``@nodename`` can be specified."
    },
    {
        "section": "ip",
        "rtype": ["netns", "docker"],
        "keyword": "nsdev",
        "at": True,
        "required": False,
        "text": "If specified, use this interface name in the netns. If not specified the first free ``eth<n>`` is chosen."
    },
    {
        "section": "ip",
        "rtype": ["netns", "docker"],
        "keyword": "macaddr",
        "at": True,
        "required": False,
        "text": "If specified, use this mac address in the netns."
    },
    {
        "section": "ip",
        "rtype": "cni",
        "keyword": "ipdev",
        "default": "eth12",
        "at": True,
        "required": False,
        "text": "The interface name in the container namespace."
    },
    {
        "section": "ip",
        "rtype": "crossbow",
        "keyword": "ipdevext",
        "at": True,
        "example": "v4",
        "default": "v4",
        "text": "The interface name extension for crossbow ipadm configuration."
    },
    {
        "section": "ip",
        "rtype": ["docker", "netns"],
        "keyword": "del_net_route",
        "at": True,
        "default": False,
        "example": "true",
        "text": "Some docker ip configuration requires dropping the network route autoconfigured when installing the ip address. In this case set this parameter to true, and also set the network parameter."
    },
    {
        "section": "ip",
        "rtype": [None, "crossbow", "amazon", "gce", "docker", "netns"],
        "keyword": "netmask",
        "at": True,
        "text": "If an ip is already plumbed on the root interface (in which case the netmask is deduced from this ip). Mandatory if the interface is dedicated to the service (dummy interface are likely to be in this case). The format is either dotted or octal for IPv4, ex: 255.255.252.0 or 22, and octal for IPv6, ex: 64.",
        "example": "255.255.255.0"
    },
    {
        "section": "ip",
        "rtype": [None, "crossbow", "amazon", "gce", "docker", "netns"],
        "keyword": "gateway",
        "at": True,
        "text": "A zone ip provisioning parameter used in the sysidcfg formatting. The format is decimal for IPv4, ex: 255.255.252.0, and octal for IPv6, ex: 64.",
        "provisioning": True
    },
    {
        "section": "disk",
        "keyword": "type",
        "inheritance": "leaf",
        "at": True,
        "default": "vg",
        "candidates": ["disk", "veritas", "vxdg", "vxvol", "raw", "rados", "md", "drbd", "loop", "zpool", "pool", "raw", "vmdg", "vdisk", "lvm", "vg", "lv", "amazon", "gce", "zvol"],
        "text": "The volume group driver to use. Leave empty to activate the native volume group manager."
    },
    {
        "section": "disk",
        "rtype": "disk",
        "keyword": "pool",
        "provisioning": True,
        "at": True,
        "text": "The name of the pool this volume was allocated from.",
    },
    {
        "section": "disk",
        "rtype": "disk",
        "keyword": "name",
        "provisioning": True,
        "at": True,
        "text": "The name of the disk.",
    },
    {
        "section": "fs",
        "rtype": "docker",
        "keyword": "driver",
        "default": "local",
        "at": True,
        "text": "The docker volume driver to use for the resource.",
        "example": "tmpfs"
    },
    {
        "section": "fs",
        "rtype": "docker",
        "keyword": "options",
        "at": True,
        "convert": "shlex",
        "text": "The docker volume create options to use for the resource. :opt:`--label` and :opt:`--opt`",
        "example": "--opt o=size=100m,uid=1000 --opt type=tmpfs --opt device=tmpfs"
    },
    {
        "section": "fs",
        "keyword": "populate",
        "at": True,
        "convert": "list",
        "provisioning": True,
        "text": "The list of modulesets providing files to install in the volume.",
        "example": "configmap.redis configmap.global"
    },
    {
        "section": "disk",
        "rtype": "zvol",
        "keyword": "name",
        "required": True,
        "at": True,
        "text": "The full name of the zfs volume in the ``<pool>/<name>`` form.",
        "example": "tank/zvol1"
    },
    {
        "section": "disk",
        "rtype": "zvol",
        "keyword": "size",
        "provisioning": True,
        "convert": "size",
        "at": True,
        "text": "The size of the zfs volume to create.",
        "example": "1g"
    },
    {
        "section": "disk",
        "rtype": "zvol",
        "keyword": "create_options",
        "provisioning": True,
        "convert": "shlex",
        "default": [],
        "at": True,
        "text": "The :cmd:`zfs create -V <name>` extra options.",
        "example": "-o dedup=on"
    },
    {
        "section": "disk",
        "rtype": "lv",
        "keyword": "name",
        "required": True,
        "at": True,
        "text": "The name of the logical volume.",
        "example": "lv1"
    },
    {
        "section": "disk",
        "rtype": ["lv", "vxvol"],
        "keyword": "vg",
        "at": True,
        "text": "The name of the volume group hosting the logical volume.",
        "example": "vg1"
    },
    {
        "section": "disk",
        "rtype": "lv",
        "keyword": "size",
        "convert": "size",
        "at": True,
        "provisioning": True,
        "text": "The size of the logical volume to provision. A size expression or <n>%{FREE|PVS|VG}.",
        "example": "10m"
    },
    {
        "section": "disk",
        "rtype": ["lv", "vxvol"],
        "keyword": "create_options",
        "convert": "shlex",
        "default": [],
        "at": True,
        "provisioning": True,
        "text": "Additional options to pass to the logical volume create command (:cmd:`lvcreate` or :cmd:`vxassist`, depending on the driver). Size and name are alread set.",
        "example": "--contiguous y"
    },
    {
        "section": "fs",
        "rtype": rcEnv.fs_non_pooling,
        "keyword": "create_options",
        "convert": "shlex",
        "default": [],
        "at": True,
        "provisioning": True,
        "text": "Additional options to pass to the logical volume create command. Size and name are alread set.",
        "example": "--contiguous y"
    },
    {
        "section": "disk",
        "rtype": "disk",
        "keyword": "disk_id",
        "at": True,
        "text": "The wwn of the disk.",
        "example": "6589cfc00000097484f0728d8b2118a6"
    },
    {
        "section": "disk",
        "rtype": "disk",
        "keyword": "array",
        "at": True,
        "provisioning": True,
        "text": "The array to provision the disk from.",
        "example": "xtremio-prod1"
    },
    {
        "section": "disk",
        "rtype": "disk",
        "keyword": "diskgroup",
        "at": True,
        "provisioning": True,
        "text": "The array disk group to provision the disk from.",
        "example": "default"
    },
    {
        "section": "disk",
        "rtype": "disk",
        "keyword": "slo",
        "at": True,
        "provisioning": True,
        "text": "The provisioned disk service level objective. This keyword is honored on arrays supporting this (ex: EMC VMAX)",
        "example": "Optimized"
    },
    {
        "section": "disk",
        "rtype": "amazon",
        "keyword": "volumes",
        "convert": "list",
        "at": True,
        "required": True,
        "text": "A whitespace separated list of amazon volumes. Any member of the list can be set to a special <key=value,key=value> value. In this case the provisioner will allocate a new volume with the specified characteristics and replace this member with the allocated volume id. The supported keys are the same as those supported by the awscli ec2 create-volume command: size, iops, availability-zone, snapshot, type and encrypted.",
        "example": "vol-123456 vol-654321"
    },
    {
        "section": "disk",
        "rtype": "raw",
        "keyword": "devs",
        "convert": "set",
        "at": True,
        "required": True,
        "text": "a list of device paths or <src>:<dst> device paths mappings, whitespace separated. Those devices are owned by the service and scsi reservation policy is applied to them.",
        "example": "/dev/mapper/svc.d0:/dev/oracle/redo001 /dev/mapper/svc.d1"
    },
    {
        "section": "disk",
        "rtype": "raw",
        "keyword": "zone",
        "at": True,
        "text": "The zone name the raw resource is linked to. If set, the raw files are configured from the global reparented to the zonepath.",
        "example": "zone1"
    },
    {
        "section": "disk",
        "rtype": "raw",
        "keyword": "create_char_devices",
        "at": True,
        "default": False,
        "convert": "boolean",
        "text": "On Linux, char devices are not automatically created when devices are discovered. If set to True (the default), the raw resource driver will create and delete them using the raw kernel driver.",
        "example": "false"
    },
    {
        "section": "disk",
        "keyword": "node",
        "rtype": "gandi",
        "at": True,
        "default_text": "The local node name.",
        "text": "The node name from the Gandi api point of view.",
    },
    {
        "section": "disk",
        "keyword": "user",
        "rtype": ["gandi", "raw"],
        "at": True,
        "example": "root",
        "text": "The user that should be owner of the device. Either in numeric or symbolic form."
    },
    {
        "section": "disk",
        "keyword": "group",
        "rtype": ["gandi", "raw"],
        "at": True,
        "example": "sys",
        "text": "The group that should be owner of the device. Either in numeric or symbolic form."
    },
    {
        "section": "disk",
        "keyword": "perm",
        "rtype": ["gandi", "raw"],
        "at": True,
        "example": "600",
        "text": "The permissions the device should have. A string representing the octal permissions."
    },
    {
        "section": "disk",
        "rtype": ["lvm", "vg", "veritas", "vxdg", "vxvol"],
        "keyword": "name",
        "at": True,
        "required": True,
        "text": "The name of the volume group"
    },
    {
        "section": "disk",
        "rtype": ["lvm", "vg"],
        "keyword": "options",
        "default": "",
        "at": True,
        "provisioning": True,
        "text": "The vgcreate options to use upon vg provisioning."
    },
    {
        "section": "disk",
        "required": False,
        "at": True,
        "keyword": "uuid",
        "rtype": "md",
        "text": "The md uuid to use with mdadm assemble commands"
    },
    {
        "section": "disk",
        "required": True,
        "at": True,
        "keyword": "devs",
        "convert": "list",
        "rtype": "md",
        "provisioning": True,
        "example": "/dev/rbd0 /dev/rbd1",
        "text": "The md member devices to use with mdadm create command"
    },
    {
        "section": "disk",
        "required": True,
        "at": True,
        "keyword": "level",
        "rtype": "md",
        "provisioning": True,
        "required": True,
        "example": "raid1",
        "text": "The md raid level to use with mdadm create command (see mdadm man for values)"
    },
    {
        "section": "disk",
        "at": True,
        "keyword": "layout",
        "rtype": ["md"],
        "provisioning": True,
        "text": "The md raid layout to use with mdadm create command (see mdadm man for values)"
    },
    {
        "section": "disk",
        "at": True,
        "keyword": "chunk",
        "rtype": "md",
        "provisioning": True,
        "example": "128k",
        "text": "The md chunk size to use with mdadm create command. Values are converted to kb and rounded to 4."
    },
    {
        "section": "disk",
        "at": True,
        "keyword": "spares",
        "rtype": "md",
        "provisioning": True,
        "convert": "integer",
        "example": "0",
        "default": 0,
        "text": "The md number of spare devices to use with mdadm create command"
    },
    {
        "section": "sync",
        "keyword": "pairs",
        "convert": "list",
        "rtype": "radosclone",
        "required": True,
        "at": True,
        "text": "The rados clone device pairs."
    },
    {
        "section": "disk",
        "keyword": "client_id",
        "rtype": "rados",
        "text": "Client id to use for authentication with the rados servers."
    },
    {
        "section": "disk",
        "keyword": "keyring",
        "rtype": "rados",
        "text": "keyring to look for the client id secret for authentication with the rados servers."
    },
    {
        "section": "disk",
        "keyword": "lock",
        "candidates": ["exclusive", "shared", "None"],
        "rtype": "rados",
        "text": "Locking mode for the rados images"
    },
    {
        "section": "disk",
        "keyword": "lock_shared_tag",
        "rtype": "rados",
        "depends": [('lock', ['shared'])],
        "text": "The tag to use upon rados image locking in shared mode"
    },
    {
        "section": "disk",
        "rtype": "rados",
        "keyword": "image_format",
        "provisioning": True,
        "default": "2",
        "text": "The rados image format"
    },
    {
        "section": "disk",
        "rtype": ["rados", "vxvol"],
        "keyword": "size",
        "convert": "size",
        "provisioning": True,
        "text": "The block device size in size expression format."
    },
    {
        "section": "disk",
        "rtype": "rados",
        "keyword": "images",
        "convert": "list",
        "required": True,
        "text": "The rados image names handled by this vg resource. whitespace separated."
    },
    {
        "section": "disk",
        "rtype": "radossnap",
        "keyword": "images",
        "convert": "list",
        "required": True,
        "text": "The rados image names handled by this sync resource. whitespace separated."
    },
    {
        "section": "disk",
        "rtype": ["lvm", "vg"],
        "keyword": "dsf",
        "candidates": (True, False),
        "default": True,
        "convert": "boolean",
        "text": "HP-UX only. 'dsf' must be set to false for LVM to use never-multipathed ``/dev/dsk/...`` devices. Otherwize, ad-hoc multipathed ``/dev/disk/...`` devices."
    },
    {
        "section": "disk",
        "keyword": "scsireserv",
        "default": False,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "If set to ``true``, OpenSVC will try to acquire a type-5 (write exclusive, registrant only) scsi3 persistent reservation on every path to every disks held by this resource. Existing reservations are preempted to not block service start-up. If the start-up was not legitimate the data are still protected from being written over from both nodes. If set to ``false`` or not set, :kw:`scsireserv` can be activated on a per-resource basis."
    },
    {
        "section": "disk",
        "keyword": "promote_rw",
        "default": False,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "If set to ``true``, OpenSVC will try to promote the base devices to read-write on start."
    },
    {
        "section": "disk",
        "keyword": "no_preempt_abort",
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "If set to ``true``, OpenSVC will preempt scsi reservation with a preempt command instead of a preempt and and abort. Some scsi target implementations do not support this last mode (esx). If set to ``false`` or not set, :kw:`no_preempt_abort` can be activated on a per-resource basis."
    },
    {
        "section": "fs",
        "keyword": "promote_rw",
        "default": False,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "If set to ``true``, OpenSVC will try to promote the base devices to read-write on start."
    },
    {
        "section": "fs",
        "keyword": "scsireserv",
        "default": False,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "If set to ``true``, OpenSVC will try to acquire a type-5 (write exclusive, registrant only) scsi3 persistent reservation on every path to every disks held by this resource. Existing reservations are preempted to not block service start-up. If the start-up was not legitimate the data are still protected from being written over from both nodes. If set to ``false`` or not set, :kw:`scsireserv` can be activated on a per-resource basis."
    },
    {
        "section": "fs",
        "keyword": "no_preempt_abort",
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "If set to ``true``, OpenSVC will preempt scsi reservation with a preempt command instead of a preempt and and abort. Some scsi target implementations do not support this last mode (esx). If set to ``false`` or not set, :kw:`no_preempt_abort` can be activated on a per-resource basis."
    },
    {
        "section": "container",
        "keyword": "promote_rw",
        "default": False,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "If set to ``true``, OpenSVC will try to promote the base devices to read-write on start."
    },
    {
        "section": "container",
        "keyword": "scsireserv",
        "default": False,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "If set to ``true``, OpenSVC will try to acquire a type-5 (write exclusive, registrant only) scsi3 persistent reservation on every path to every disks held by this resource. Existing reservations are preempted to not block service start-up. If the start-up was not legitimate the data are still protected from being written over from both nodes. If set to ``false`` or not set, :kw:`scsireserv` can be activated on a per-resource basis."
    },
    {
        "section": "container",
        "keyword": "no_preempt_abort",
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "If set to ``true``, OpenSVC will preempt scsi reservation with a preempt command instead of a preempt and and abort. Some scsi target implementations do not support this last mode (esx). If set to ``false`` or not set, :kw:`no_preempt_abort` can be activated on a per-resource basis."
    },
    {
        "sections": ["task", "container"],
        "rtype": ["oci", "docker", "podman"],
        "keyword": "start_timeout",
        "convert": "duration",
        "at": True,
        "text": "Wait for <duration> before declaring the container action a failure.",
        "default": "2",
        "example": "5"
    },
    {
        "section": "container",
        "rtype": rcEnv.vt_cloud+["ldom", "hpvm", "kvm", "xen", "vbox", "ovm", "esx", "zone", "lxd", "lxc", "jail", "vz", "srp"],
        "keyword": "start_timeout",
        "convert": "duration",
        "at": True,
        "text": "Wait for <duration> before declaring the container action a failure.",
        "default": "240",
        "example": "180"
    },
    {
        "section": "container",
        "rtype": rcEnv.vt_cloud+["ldom", "hpvm", "kvm", "xen", "vbox", "ovm", "esx", "zone", "lxd", "lxc", "jail", "vz", "srp", "oci", "docker", "podman"],
        "keyword": "stop_timeout",
        "convert": "duration",
        "at": True,
        "text": "Wait for <duration> before declaring the container action a failure.",
        "default": "120",
        "example": "180"
    },
    {
        "section": "container",
        "rtype": ["vbox"],
        "keyword": "headless",
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "Enable VM startup in headless mode",
    },
    {
        "section": "disk",
        "rtype": ["lvm", "vg", "veritas", "vxdg"],
        "keyword": "pvs",
        "required": True,
        "text": "The list of paths to the physical volumes of the volume group.",
        "provisioning": True
    },
    {
        "section": "disk",
        "rtype": ["zpool", "pool"],
        "keyword": "multihost",
        "convert": "tristate",
        "at": True,
        "text": "If set to ``true``, sets zfs option ``multihost=on`` on start if not already set. This requires all nodes to be booted with a /etc/hostid installed, preferrably generated by the zgenhostid command."
    },
    {
        "section": "disk",
        "rtype": "zpool",
        "keyword": "create_options",
        "provisioning": True,
        "convert": "shlex",
        "default": [],
        "at": True,
        "text": "The zpool create extra options.",
        "example": "-O dedup=on"
    },
    {
        "section": "disk",
        "rtype": ["zpool", "pool"],
        "keyword": "vdev",
        "required": True,
        "convert": "list",
        "at": True,
        "provisioning": True,
        "text": "The vdev list, including optional parity keywords, as would be passed to zpool create."
    },
    {
        "section": "disk",
        "rtype": ["zpool", "pool"],
        "keyword": "name",
        "required": True,
        "at": True,
        "text": "The name of the zfs pool"
    },
    {
        "rtype": "zpool",
        "section": "disk",
        "keyword": "zone",
        "at": True,
        "text": "The zone name the zpool refers to. If set, the zpool is activated in the zone context."
    },
    {
        "section": "disk",
        "rtype": "vmdg",
        "keyword": "container_id",
        "required": True,
        "at": True,
        "text": "The id of the container whose configuration to extract the disk mapping from."
    },
    {
        "section": "disk",
        "rtype": "drbd",
        "keyword": "res",
        "required": True,
        "text": "The name of the drbd resource associated with this service resource. OpenSVC expect the resource configuration file to reside in ``/etc/drbd.d/resname.res``. The :c-res:`sync#i0` resource will take care of replicating this file to remote nodes."
    },
    {
        "section": "share",
        "keyword": "type",
        "inheritance": "leaf",
        "candidates": ["nfs"],
        "text": "The type of share.",
        "required": True,
    },
    {
        "section": "share",
        "keyword": "path",
        "rtype": "nfs",
        "at": True,
        "required": True,
        "text": "The fullpath of the directory to share."
    },
    {
        "section": "share",
        "keyword": "opts",
        "rtype": "nfs",
        "at": True,
        "required": True,
        "text": "The NFS share export options, as they woud be set in /etc/exports or passed to Solaris share command."
    },
    {
        "section": "fs",
        "keyword": "dev",
        "at": True,
        "required": True,
        "text": "The block device file or filesystem image file hosting the filesystem to mount. Different device can be set up on different nodes using the ``dev@nodename`` syntax"
    },
    {
        "section": "fs",
        "keyword": "zone",
        "at": True,
        "text": "The zone name the fs refers to. If set, the fs mount point is reparented into the zonepath rootfs."
    },
    {
        "section": "fs",
        "keyword": "vg",
        "rtype": rcEnv.fs_non_pooling,
        "required": False,
        "at": True,
        "text": "The name of the disk group the filesystem device should be provisioned from.",
        "provisioning": True
    },
    {
        "section": "fs",
        "rtype": rcEnv.fs_non_pooling,
        "keyword": "size",
        "required": False,
        "convert": "size",
        "at": True,
        "text": "The size of the logical volume to provision for this filesystem. A size expression or <n>%{FREE|PVS|VG}.",
        "provisioning": True
    },
    {
        "section": "fs",
        "rtype": "zfs",
        "keyword": "size",
        "required": False,
        "convert": "size",
        "at": True,
        "text": "The quota in MB of the provisioned dataset.",
        "provisioning": True
    },
    {
        "section": "fs",
        "keyword": "mnt",
        "at": True,
        "required": True,
        "text": "The mount point where to mount the filesystem."
    },
    {
        "section": "fs",
        "keyword": "mnt_opt",
        "at": True,
        "text": "The mount options."
    },
    {
        "section": "fs",
        "keyword": "mkfs_opt",
        "convert": "shlex",
        "default": [],
        "provisioning": True,
        "at": True,
        "text": "Eventual mkfs additional options."
    },
    {
        "section": "fs",
        "keyword": "stat_timeout",
        "convert": "duration",
        "default": 5,
        "at": True,
        "text": "The maximum wait time for a stat call to respond. When expired, the resource status is degraded is to warn, which might cause a TOC if the resource is monitored."
    },
    {
        "section": "fs",
        "keyword": "type",
        "inheritance": "leaf",
        "at": True,
        "required": True,
        "strict_candidates": False,
        "candidates": ["flag", "directory", "zfs", "docker"]+rcEnv.fs_non_pooling,
        "text": "The filesystem type or 'directory'. Used to determine the fsck command to use."
    },
    {
        "section": "fs",
        "keyword": "snap_size",
        "at": True,
        "text": "If this filesystem is build on a snapable logical volume or is natively snapable (jfs, vxfs, ...) this setting overrides the default 10% of the filesystem size to compute the snapshot size. The snapshot is created by snap-enabled rsync-type sync resources. The unit is Megabytes."
    },
    {
        "section": "fs",
        "keyword": "path",
        "rtype": "directory",
        "at": True,
        "required": True,
        "text": "The fullpath of the directory to create."
    },
    {
        "section": "fs",
        "keyword": "user",
        "rtype": "directory",
        "at": True,
        "example": "root",
        "text": "The user that should be owner of the directory. Either in numeric or symbolic form."
    },
    {
        "section": "fs",
        "keyword": "group",
        "rtype": "directory",
        "at": True,
        "example": "sys",
        "text": "The group that should be owner of the directory. Either in numeric or symbolic form."
    },
    {
        "section": "fs",
        "keyword": "perm",
        "rtype": "directory",
        "at": True,
        "example": "1777",
        "text": "The permissions the directory should have. A string representing the octal permissions."
    },
    {
        "section": "disk",
        "rtype": "loop",
        "keyword": "size",
        "at": True,
        "required": True,
        "default": "100m",
        "convert": "size",
        "text": "The size of the loop file to provision.",
        "provisioning": True
    },
    {
        "section": "disk",
        "rtype": "loop",
        "at": True,
        "keyword": "file",
        "required": True,
        "text": "The loopback device backing file full path."
    },
    {
        "section": "sync",
        "keyword": "filer",
        "rtype": "netapp",
        "required": True,
        "at": True,
        "text": "The Netapp filer resolvable host name used by the node.  Different filers can be set up for each node using the ``filer@nodename`` syntax."
    },
    {
        "section": "sync",
        "keyword": "path",
        "rtype": "netapp",
        "required": True,
        "text": "Specifies the volume or qtree to drive snapmirror on."
    },
    {
        "section": "sync",
        "keyword": "user",
        "rtype": "netapp",
        "required": True,
        "default": "nasadm",
        "text": "Specifies the user used to ssh connect the filers. Nodes should be trusted by keys to access the filer with this user."
    },
    {
        "section": "sync",
        "keyword": "pairs",
        "convert": "list",
        "at": True,
        "rtype": "ibmdssnap",
        "required": True,
        "text": "Whitespace-separated list of device pairs.",
        "example": "0065:0073 0066:0074"
    },
    {
        "section": "sync",
        "keyword": "array",
        "at": True,
        "rtype": "ibmdssnap",
        "required": True,
        "text": "The name of the array holding the source devices and their paired devices.",
        "example": "IBM.2243-12ABC00"
    },
    {
        "section": "sync",
        "keyword": "bgcopy",
        "at": True,
        "rtype": "ibmdssnap",
        "candidates": [True, False],
        "required": True,
        "convert": "boolean",
        "text": "Initiate a background copy of the source data block to the paired devices upon resync."
    },
    {
        "section": "sync",
        "keyword": "recording",
        "at": True,
        "rtype": "ibmdssnap",
        "candidates": [True, False],
        "required": True,
        "convert": "boolean",
        "text": "Track only changed data blocks instead of copying the whole source data to the paired devices."
    },
    {
        "section": "sync",
        "keyword": "name",
        "at": True,
        "rtype": "nexenta",
        "required": True,
        "text": "The name of the Nexenta autosync configuration."
    },
    {
        "section": "sync",
        "keyword": "filer",
        "at": True,
        "rtype": "nexenta",
        "required": True,
        "text": "The name of the Nexenta local head. Must be set for each node using the scoping syntax."
    },
    {
        "section": "sync",
        "keyword": "path",
        "at": True,
        "rtype": "nexenta",
        "required": True,
        "text": "The path of the zfs to synchronize, as seen by the Nexenta heads."
    },
    {
        "section": "sync",
        "keyword": "reversible",
        "at": True,
        "rtype": "nexenta",
        "candidates": [True, False],
        "required": True,
        "text": "Defines if the replication link can be reversed. Set to ``false`` for prd to drp replications to protect production data."
    },
    {
        "section": "sync",
        "keyword": "array",
        "rtype": "hp3parsnap",
        "required": True,
        "at": True,
        "text": "Name of the HP 3par array to send commands to."
    },
    {
        "section": "sync",
        "keyword": "vv_names",
        "convert": "list",
        "rtype": "hp3parsnap",
        "required": True,
        "at": True,
        "text": "The names of snapshot VV or sets of VV to update."
    },
    {
        "section": "sync",
        "keyword": "array",
        "rtype": "hp3par",
        "required": True,
        "at": True,
        "text": "Name of the HP 3par array to send commands to."
    },
    {
        "section": "sync",
        "keyword": "mode",
        "rtype": "hp3par",
        "required": True,
        "candidates": ["async", "sync"],
        "text": "Replication mode: Synchronous or Asynchronous"
    },
    {
        "section": "sync",
        "keyword": "method",
        "rtype": "hp3par",
        "candidates": ["ssh", "cli"],
        "default": "ssh",
        "at": True,
        "text": "The method to use to submit commands to the arrays."
    },
    {
        "section": "sync",
        "keyword": "rcg",
        "rtype": "hp3par",
        "required": True,
        "at": True,
        "text": "Name of the HP 3par remote copy group. The scoping syntax must be used to fully describe the replication topology."
    },
    {
        "section": "sync",
        "keyword": "eva_name",
        "rtype": "evasnap",
        "required": True,
        "text": "Name of the HP EVA array hosting the source and snapshot devices."
    },
    {
        "section": "sync",
        "keyword": "snap_name",
        "rtype": "evasnap",
        "required": True,
        "text": "Name of the snapshot objectname as seen in sssu."
    },
    {
        "section": "sync",
        "keyword": "pairs",
        "rtype": "evasnap",
        "required": True,
        "text": "A json-formatted list of dictionaries representing the device pairs. Each dict must have the ``src``, ``dst`` and ``mask`` keys. The ``mask`` key value is a list of ``\\<hostpath>\\<lunid>`` strings."
    },
    {
        "section": "sync",
        "keyword": "array",
        "rtype": "necism",
        "required": True,
        "text": "Name of the NEC ISM array to send commands to."
    },
    {
        "section": "sync",
        "keyword": "devs",
        "rtype": "necism",
        "required": True,
        "text": "A whitespace-separated list of ``SV:LD``."
    },
    {
        "section": "sync",
        "keyword": "symid",
        "at": True,
        "rtype": "symsrdfs",
        "required": True,
        "text": "Id of the local symmetrix array hosting the symdg. This parameter is usually scoped to define different array ids for different nodes."
    },
    {
        "section": "sync",
        "keyword": "symdg",
        "at": False,
        "rtype": "symsrdfs",
        "required": True,
        "text": "Name of the symmetrix device group where the source and target devices are grouped."
    },
    {
        "section": "sync",
        "keyword": "rdfg",
        "at": False,
        "rtype": "symsrdfs",
        "convert": "integer",
        "required": True,
        "text": "Name of the RDF group pairing the source and target devices."
    },
    {
        "section": "sync",
        "keyword": "precopy",
        "at": True,
        "rtype": "symclone",
        "default": True,
        "convert": "boolean",
        "text": "Use :opt:`-precopy` on recreate."
    },
    {
        "section": "sync",
        "keyword": "recreate_timeout",
        "at": True,
        "rtype": ["symclone", "symsnap"],
        "default": 300,
        "convert": "duration",
        "text": "Maximum wait time for the clone to reach the created state."
    },
    {
        "section": "sync",
        "keyword": "restore_timeout",
        "at": True,
        "rtype": ["symclone", "symsnap"],
        "default": 300,
        "convert": "duration",
        "text": "Maximum wait time for the clone to reach the restored state."
    },
    {
        "section": "sync",
        "keyword": "symid",
        "rtype": ["symclone", "symsnap"],
        "required": True,
        "text": "Identifier of the symmetrix array hosting the source and target devices pairs pointed by :kw:`pairs`."
    },
    {
        "section": "sync",
        "keyword": "pairs",
        "convert": "list",
        "rtype": ["symclone", "symsnap"],
        "required": True,
        "at": True,
        "text": "Whitespace-separated list of devices ``<src>:<dst>`` devid pairs to drive with this resource.",
        "example": "00B60:00B61 00B62:00B63",
    },
    {
        "section": "sync",
        "keyword": "consistent",
        "rtype": ["symclone", "symsnap"],
        "at": True,
        "default": True,
        "convert": "boolean",
        "text": "Use :opt:`-consistent` in symclone commands.",
    },
    {
        "section": "sync",
        "keyword": "src",
        "rtype": "dds",
        "required": True,
        "text": "Points the origin of the snapshots to replicate from."
    },
    {
        "section": "sync",
        "keyword": "dst",
        "rtype": "dds",
        "at": True,
        "required": True,
        "text": "Target file or block device. Optional. Defaults to src. Points the media to replay the binary-delta received from source node to. This media must have a size superior or equal to source."
    },
    {
        "section": "sync",
        "keyword": "target",
        "convert": "list",
        "rtype": "dds",
        "required": True,
        "candidates": ['nodes', 'drpnodes'],
        "text": "Accepted values are ``drpnodes``, ``nodes`` or both, whitespace-separated. Points the target nodes to replay the binary-deltas on. Be warned that starting the service on a target node without a stop-sync_update-start cycle, will break the synchronization, so this mode is usually restricted to drpnodes sync, and should not be used to replicate data between nodes with automated services failover."
    },
    {
        "section": "sync",
        "keyword": "snap_size",
        "rtype": "dds",
        "text": "Default to 10% of origin. In MB, rounded to physical extent boundaries by lvm tools. Size of the snapshots created by OpenSVC to extract binary deltas from. Opensvc creates at most 2 snapshots : one short-lived to gather changed data from, and one long-lived to gather changed chunks list from. Volume groups should have the necessary space always available."
    },
    {
        "section": "disk",
        "rtype": "vdisk",
        "keyword": "path",
        "required": True,
        "at": True,
        "text": "Path of the device or file used as a virtual machine disk. The path@nodename can be used to to set up different path on each node."
    },
    {
        "section": "task",
        "keyword": "type",
        "candidates": ["host", "oci", "docker", "podman"],
        "default": "host",
        "text": "The type of task. Default tasks run on the host, their use is limited to the cluster admin population. Containerized tasks are safe for unprivileged population."
    },
    {
        "section": "task",
        "keyword": "command",
        "at": True,
        "required": True,
        "rtype": "host",
        "text": "The command to execute on 'run' action and at scheduled interval. The default schedule for tasks is ``@0``.",
        "example": "/srv/{name}/data/scripts/backup.sh"
    },
    {
        "section": "task",
        "keyword": "timeout",
        "convert": "duration",
        "at": True,
        "text": "Wait for <duration> before declaring the task run action a failure. If no timeout is set, the agent waits indefinitely for the task command to exit.",
        "example": "5m"
    },
    {
        "section": "task",
        "keyword": "snooze",
        "at": True,
        "default": 0,
        "convert": "duration",
        "text": "Snooze the service before running the task, so if the command is known to cause a service status degradation the user can decide to snooze alarms for the duration set as value.",
        "example": "10m"
    },
    {
        "section": "task",
        "keyword": "log",
        "at": True,
        "default": True,
        "convert": "boolean",
        "text": "Log the task outputs in the service log.",
    },
    {
        "section": "task",
        "keyword": "confirmation",
        "at": True,
        "default": False,
        "convert": "boolean",
        "candidates": (True, False),
        "text": "If set to True, ask for an interactive confirmation to run the task. This flag can be used for dangerous tasks like data-restore.",
    },
    {
        "section": "task",
        "keyword": "on_error",
        "at": True,
        "text": "A command to execute on :c-action:`run` action if :kw:`command` returned an error.",
        "example": "/srv/{name}/data/scripts/task_on_error.sh"
    },
    {
        "section": "task",
        "keyword": "check",
        "candidates": [None, "last_run"],
        "at": True,
        "text": "If set to 'last_run', the last run retcode is used to report a task resource status. If not set (default), the status of a task is always n/a.",
        "example": "last_run"
    },
    {
        "section": "task",
        "keyword": "user",
        "at": True,
        "text": "The user to impersonate when running the task command. The default user is root.",
        "example": "admin"
    },
    {
        "section": "task",
        "keyword": "schedule",
        "at": True,
        "text": "Set the this task run schedule. See ``usr/share/doc/node.conf`` for the schedule syntax reference.",
        "example": '["00:00-01:00@61 mon", "02:00-03:00@61 tue-sun"]'
    },
    {
        "section": "volume",
        "keyword": "name",
        "at": True,
        "required": False,
        "text": "The volume service name. A service can only reference volumes in the same namespace."
    },
    {
        "section": "volume",
        "keyword": "type",
        "provisioning": True,
        "at": True,
        "required": False,
        "text": "The type of the pool to allocate from. The selected pool will be the one matching type and capabilities and with the maximum available space."
    },
    {
        "section": "volume",
        "keyword": "access",
        "default": "rwo",
        "candidates": ["rwo", "roo", "rwx", "rox"],
        "provisioning": True,
        "at": True,
        "required": False,
        "text": "The access mode of the volume. ``rwo`` is Read Write Once, ``roo`` is Read Only Once, ``rwx`` is Read Write Many, ``rox`` is Read Only Many. ``rox`` and ``rwx`` modes are served by flex volume services.",
    },
    {
        "section": "volume",
        "keyword": "size",
        "at": True,
        "convert": "size",
        "provisioning": True,
        "required": True,
        "text": "The size to allocate in the pool."
    },
    {
        "section": "volume",
        "keyword": "pool",
        "at": True,
        "provisioning": True,
        "text": "The name of the pool to allocate from."
    },
    {
        "section": "volume",
        "keyword": "format",
        "at": True,
        "provisioning": True,
        "default": True,
        "convert": "boolean",
        "text": "If true the volume translator will also produce a fs resource layered over the disk allocated in the pool."
    },
    {
        "section": "volume",
        "keyword": "configs",
        "at": True,
        "convert": "shlex",
        "default": [],
        "text": "The whitespace separated list of ``<config name>/<key>:<volume relative path>:<options>``.",
        "example": "conf/mycnf:/etc/mysql/my.cnf:ro,mode=0640 conf/sysctl:/etc/sysctl.d/01-db.conf"
    },
    {
        "section": "volume",
        "keyword": "secrets",
        "at": True,
        "rtype": ["shm"],
        "convert": "shlex",
        "default": [],
        "text": "The whitespace separated list of ``<secret name>/<key>:<volume relative path>:<options>``.",
        "example": "cert/pem:server.pem cert/key:server.key:mode=0600"
    },
    {
        "section": "expose",
        "keyword": "type",
        "inheritance": "leaf",
        "at": True,
        "candidates": ["envoy", "gobetween"],
        "text": "The type of expose.",
        "default": "envoy",
    },
    {
        "section": "expose",
        "keyword": "cluster_data",
        "rtype": ["envoy"],
        "convert": "json",
        "at": True,
        "text": "The envoy protocol compliant data in json format used to bootstrap the Cluster config messages. Parts of this structure, like endpoints, are amended to reflect the actual cluster state."
    },
    {
        "section": "expose",
        "keyword": "filter_config_data",
        "rtype": ["envoy"],
        "convert": "json",
        "at": True,
        "text": "The envoy protocol compliant data in json format used to bootstrap the Listener filter config messages. Parts of this structure, like routes, are amended by more specific keywords."
    },
    {
        "section": "expose",
        "keyword": "port",
        "rtype": ["envoy", "gobetween"],
        "convert": "integer",
        "at": True,
        "required": True,
        "text": "The port number of the endpoint."
    },
    {
        "section": "expose",
        "keyword": "protocol",
        "rtype": ["envoy", "gobetween"],
        "candidates": ["tcp", "udp"],
        "default": "tcp",
        "at": True,
        "text": "The protocol of the endpoint."
    },
    {
        "section": "expose",
        "keyword": "listener_addr",
        "rtype": "envoy",
        "default_text": "The main proxy ip address.",
        "at": True,
        "text": "The public ip address to expose from."
    },
    {
        "section": "expose",
        "keyword": "listener_port",
        "rtype": "envoy",
        "convert": "integer",
        "default_text": "The expose <port>.",
        "at": True,
        "text": "The public port number to expose from. The special value 0 is interpreted as a request for auto-allocation."
    },
    {
        "section": "expose",
        "keyword": "sni",
        "rtype": "envoy",
        "at": True,
        "convert": "list",
        "text": "The SNI server names to match on the proxy to select this service endpoints. The socket server must support TLS."
    },
    {
        "section": "expose",
        "keyword": "lb_policy",
        "rtype": "envoy",
        "default": "round robin",
        "candidates": ["round robin", "least_request", "ring_hash", "random", "original_dst_lb", "maglev"],
        "at": True,
        "text": "The name of the envoy cluster load balancing policy."
    },
    {
        "section": "expose",
        "keyword": "gateway",
        "rtype": ["envoy", "gobetween"],
        "at": True,
        "text": "The name of the ingress gateway that should handle this expose."
    },
    {
        "section": "expose",
        "keyword": "vhosts",
        "rtype": ["envoy"],
        "convert": "list",
        "at": True,
        "text": "The list of vhost resource identifiers for this expose."
    },
    {
        "section": "expose",
        "keyword": "listener_certificates",
        "rtype": ["envoy"],
        "convert": "list",
        "at": True,
        "text": "The TLS certificates used by the listener."
    },
    {
        "section": "expose",
        "keyword": "cluster_certificates",
        "rtype": ["envoy"],
        "convert": "list",
        "at": True,
        "text": "The TLS certificates used to communicate with cluster endpoints."
    },
    {
        "section": "expose",
        "keyword": "cluster_private_key_filename",
        "rtype": ["envoy"],
        "at": True,
        "text": "Local filesystem data source of the TLS private key used to communicate with cluster endpoints."
    },
    {
        "section": "vhost",
        "keyword": "type",
        "inheritance": "leaf",
        "at": True,
        "candidates": ["envoy"],
        "text": "The type of vhost.",
        "default": "envoy",
    },
    {
        "section": "vhost",
        "keyword": "domains",
        "rtype": ["envoy"],
        "convert": "list",
        "at": True,
        "text": "The list of http domains in this expose.",
        "default": "{name}",
        "example": "{name}"
    },
    {
        "section": "vhost",
        "keyword": "routes",
        "rtype": ["envoy"],
        "convert": "list",
        "at": True,
        "default": [],
        "text": "The list of route resource identifiers for this vhost."
    },
    {
        "section": "route",
        "keyword": "type",
        "inheritance": "leaf",
        "at": True,
        "candidates": ["envoy"],
        "text": "The type of route.",
        "default": "envoy",
    },
    {
        "section": "route",
        "keyword": "match_path",
        "rtype": ["envoy"],
        "at": True,
        "text": "If specified, the route is an exact path rule meaning that the path must exactly match the :path header once the query string is removed. Precisely one of prefix, path, regex must be set.",
    },
    {
        "section": "route",
        "keyword": "match_regex",
        "rtype": ["envoy"],
        "at": True,
        "text": " If specified, the route is a regular expression rule meaning that the regex must match the :path header once the query string is removed. The entire path (without the query string) must match the regex. The rule will not match if only a subsequence of the :path header matches the regex.",
        "example": "/b[io]t",
    },
    {
        "section": "route",
        "keyword": "match_prefix",
        "rtype": ["envoy"],
        "at": True,
        "text": " If specified, the route is a prefix rule meaning that the prefix must match the beginning of the :path header. Precisely one of prefix, path, regex must be set.",
    },
    {
        "section": "route",
        "keyword": "match_case_sensitive",
        "rtype": ["envoy"],
        "at": True,
        "text": "Indicates that prefix/path matching should be case sensitive. The default is ``true``.",
    },
    {
        "section": "route",
        "keyword": "route_prefix_rewrite",
        "rtype": ["envoy"],
        "at": True,
        "text": "The string replacing the url path prefix if matching.",
    },
    {
        "section": "route",
        "keyword": "route_host_rewrite",
        "rtype": ["envoy"],
        "at": True,
        "text": "Indicates that during forwarding, the host header will be swapped with this value.",
    },
    {
        "section": "route",
        "keyword": "route_cluster_header",
        "rtype": ["envoy"],
        "at": True,
        "text": "If the route is not a redirect (host_redirect and/or path_redirect is not specified), one of cluster, cluster_header, or weighted_clusters must be specified. When cluster_header is specified, Envoy will determine the cluster to route to by reading the value of the HTTP header named by cluster_header from the request headers. If the header is not found or the referenced cluster does not exist, Envoy will return a 404 response.",
    },
    {
        "section": "route",
        "keyword": "route_timeout",
        "rtype": ["envoy"],
        "at": True,
        "text": "Specifies the timeout for the route. If not specified, the default is 15s. Note that this timeout includes all retries.",
    },
    {
        "section": "route",
        "keyword": "redirect_host_redirect",
        "rtype": ["envoy"],
        "at": True,
        "text": "The host portion of the URL will be swapped with this value.",
    },
    {
        "section": "route",
        "keyword": "redirect_prefix_rewrite",
        "rtype": ["envoy"],
        "at": True,
        "text": "Indicates that during redirection, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request.",
    },
    {
        "section": "route",
        "keyword": "redirect_path_redirect",
        "rtype": ["envoy"],
        "at": True,
        "text": "Indicates that the route is a redirect rule. If there is a match, a 301 redirect response will be sent which swaps the path portion of the URL with this value. host_redirect can also be specified along with this option.",
    },
    {
        "section": "route",
        "keyword": "redirect_response_code",
        "rtype": ["envoy"],
        "at": True,
        "text": "The HTTP status code to use in the redirect response. The default response code is MOVED_PERMANENTLY (301).",
    },
    {
        "section": "route",
        "keyword": "redirect_https_redirect",
        "rtype": ["envoy"],
        "convert": "boolean",
        "default": False,
        "at": True,
        "text": "The scheme portion of the URL will be swapped with 'https'.",
    },
    {
        "section": "route",
        "keyword": "redirect_strip_query",
        "rtype": ["envoy"],
        "convert": "boolean",
        "default": False,
        "at": True,
        "text": "Indicates that during redirection, the query portion of the URL will be removed. Default value is ``false``.",
    },
    {
        "section": "route",
        "keyword": "hash_policies",
        "rtype": ["envoy"],
        "convert": "list",
        "at": True,
        "default": [],
        "default_text": "",
        "text": "The list of hash policy resource ids for the route. Honored if lb_policy is set to ring_hash or maglev.",
    },
    {
        "section": "hash_policy",
        "keyword": "type",
        "inheritance": "leaf",
        "candidates": ["envoy"],
        "text": "The type of hash policy.",
        "default": "envoy",
    },
    {
        "section": "hash_policy",
        "rtype": "envoy",
        "keyword": "cookie_name",
        "text": "The name of the cookie that will be used to obtain the hash key. If the cookie is not present and ttl below is not set, no hash will be produced.",
    },
    {
        "section": "hash_policy",
        "rtype": "envoy",
        "keyword": "cookie_path",
        "text": "The name of the path for the cookie. If no path is specified here, no path will be set for the cookie.",
    },
    {
        "section": "hash_policy",
        "rtype": "envoy",
        "keyword": "cookie_ttl",
        "convert": "duration",
        "text": "If specified, a cookie with the TTL will be generated if the cookie is not present. If the TTL is present and zero, the generated cookie will be a session cookie.",
    },
    {
        "section": "hash_policy",
        "rtype": "envoy",
        "keyword": "header_header_name",
        "text": "The name of the request header that will be used to obtain the hash key. If the request header is not present, no hash will be produced.",
    },
    {
        "section": "hash_policy",
        "rtype": "envoy",
        "keyword": "connection_source_ip",
        "text": "Hash on source IP address.",
    },
    {
        "section": "hash_policy",
        "rtype": "envoy",
        "keyword": "terminal",
        "convert": "boolean",
        "text": "Shortcircuits the hash computing. This field provides a fallback style of configuration: if a terminal policy doesn't work, fallback to rest of the policy list. It saves time when the terminal policy works.",
    },
    {
        "section": "certificate",
        "keyword": "type",
        "inheritance": "leaf",
        "at": True,
        "candidates": ["tls"],
        "text": "The type of certificate.",
        "default": "tls",
    },
    {
        "section": "certificate",
        "keyword": "certificate_secret",
        "rtype": ["tls"],
        "at": True,
        "text": "The name of the secret object name hosting the certificate files. The secret must have the certificate_chain and server_key keys set. This setting makes the certificate served to envoy via the secret discovery service, which allows its live rotation."
    },
    {
        "section": "certificate",
        "keyword": "validation_secret",
        "rtype": ["tls"],
        "at": True,
        "text": "The name of the secret object name hosting the certificate autority files for certificate_secret validation. The secret must have the trusted_ca and verify_certificate_hash keys set. This setting makes the validation data served to envoy via the secret discovery service, which allows certificates live rotation."
    },
    {
        "section": "certificate",
        "keyword": "certificate_chain_filename",
        "rtype": ["tls"],
        "at": True,
        "text": "Local filesystem data source of the TLS certificate chain."
    },
    {
        "section": "certificate",
        "keyword": "private_key_filename",
        "rtype": ["tls"],
        "at": True,
        "text": "Local filesystem data source of the TLS private key."
    },
    {
        "section": "certificate",
        "keyword": "certificate_chain_inline_string",
        "rtype": ["tls"],
        "at": True,
        "text": "String inlined data source of the TLS certificate chain."
    },
    {
        "section": "certificate",
        "keyword": "private_key_inline_string",
        "rtype": ["tls"],
        "at": True,
        "text": "String inlined filesystem data source of the TLS private key. A reference to a secret for example."
    },
    {
        "sections": SECTIONS,
        "keyword": "tags",
        "convert": "set",
        "generic": True,
        "at": True,
        "candidates": None,
        "default": set(),
        "default_text": "",
        "example": "encap noaction",
        "text": "A list of tags. Arbitrary tags can be used to limit action scope to resources with a specific tag. Some tags can influence the driver behaviour. For example :c-tag:`noaction` avoids any state changing action from the driver and implies ``optional=true``, :c-tag:`nostatus` forces the status to n/a."
    },
    {
        "sections": SECTIONS,
        "keyword": "subset",
        "inheritance": "leaf",
        "generic": True,
        "at": True,
        "text": "Assign the resource to a specific subset."
    },
    {
        "sections": SECTIONS,
        "keyword": "restart",
        "generic": True,
        "at": True,
        "default": 0,
        "convert": "integer",
        "text": "The agent will try to restart a resource <n> times before falling back to the monitor action. A resource restart is triggered if the resource is not disabled and its status is not up, and the node is not frozen, and the service instance is not frozen and its local expect is set to ``started``. If a resource has a restart set to a value >0, its status is evaluated at the frequency defined by :kw:`DEFAULT.monitor_schedule` instead of the frequency defined by :kw:`DEFAULT.status_schedule`."
    },
    {
        "sections": SECTIONS,
        "keyword": "provision",
        "generic": True,
        "at": True,
        "candidates": (True, False),
        "default": True,
        "convert": "boolean",
        "text": "Set to false to skip the resource on provision and unprovision actions. Warning: provisioning implies destructive operations like formating. Unprovisioning does not keep a copy of the service data."
    },
    {
        "sections": SECTIONS,
        "keyword": "unprovision",
        "generic": True,
        "at": True,
        "candidates": (True, False),
        "default": True,
        "convert": "boolean",
        "text": "Set to false to skip the resource on unprovision actions. Warning: Unprovisioning does not keep a copy of the service data."
    },
    {
        "sections": SECTIONS,
        "keyword": "shared",
        "generic": True,
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "Set to ``true`` to skip the resource on provision and unprovision actions if the action has already been done by a peer. Shared resources, like vg built on SAN disks must be provisioned once. All resources depending on a shared resource must also be flagged as shared."
    },
    {
        "sections": SECTIONS,
        "keyword": "encap",
        "generic": True,
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "Set to ``true`` to ignore this resource in the nodes context and consider it in the encapnodes context. The resource is thus handled by the agents deployed in the service containers."
    },
    {
        "sections": SECTIONS,
        "keyword": "monitor",
        "generic": True,
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "A down monitored resource will trigger a node suicide if the monitor thinks it should be up and the resource can not be restarted."
    },
    {
        "sections": SECTIONS,
        "keyword": "disable",
        "inheritance": "leaf",
        "generic": True,
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "A disabled resource will be ignored on service startup and shutdown. Its status is always reported ``n/a``.\n\nSet in DEFAULT, the whole service is disabled. A disabled service does not honor :c-action:`start` and :c-action:`stop` actions. These actions immediately return success.\n\n:cmd:`sudo svcmgr -s <path> disable` only sets :kw:`DEFAULT.disable`. As resources disabled state is not changed, :cmd:`sudo svcmgr -s <path> enable` does not enable disabled resources."
    },
    {
        "sections": SECTIONS,
        "keyword": "optional",
        "generic": True,
        "at": True,
        "convert": "tristate",
        "default_text": "true for tasks, syncs and resources tagged 'noaction', else false",
        "text": "Action failures on optional resources are logged but do not stop the action sequence. Also the optional resource status is not aggregated to the instance 'availstatus', but aggregated to the 'overallstatus'. Resource tagged :c-tag:`noaction` and sync resources are automatically considered optional. Useful for resources like dump filesystems for example."
    },
    {
        "sections": SECTIONS,
        "keyword": "standby",
        "generic": True,
        "at": True,
        "default": False,
        "candidates": (True, False),
        "convert": "boolean",
        "text": "Always start the resource, even on standby instances. The daemon is responsible for starting standby resources. A resource can be set standby on a subset of nodes using keyword scoping.\n\nA typical use-case is sync'ed fs on non-shared disks: the remote fs must be mounted to not overflow the underlying fs.\n\n.. warning:: Don't set shared resources standby: fs on shared disks for example."
    },
    {
        "sections": SECTIONS,
        "keyword": "always_on",
        "generic": True,
        "convert": "list",
        "default": [],
        "default_text": "",
        "candidates": ['nodes', 'drpnodes'],
        "strict_candidates": False,
        "text": "Possible values are ``nodes``, ``drpnodes`` or ``nodes drpnodes``, or a list of nodes. Sets the nodes on which the resource is always kept up. Primary usage is file synchronization receiving on non-shared disks. Don't set this on shared disk !! danger !!"
    },
    {
        "sections": SECTIONS,
        "keyword": "pre_unprovision",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`unprovision` action. Errors do not interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "post_unprovision",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`unprovision` action. Errors do not interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "pre_provision",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`provision` action. Errors do not interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "post_provision",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`provision` action. Errors do not interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "pre_start",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`start` action. Errors do not interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "post_start",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`start` action. Errors do not interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "pre_stop",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`stop` action. Errors do not interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "post_stop",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`stop` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "pre_sync_nodes",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_nodes` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "post_sync_nodes",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_nodes` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "pre_sync_drp",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_drp` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "post_sync_drp",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_drp` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "pre_sync_restore",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_restore` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "post_sync_restore",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_restore` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "pre_sync_resync",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_resync` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "post_sync_resync",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_resync` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "pre_sync_update",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_update` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "post_sync_update",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_update` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "task"],
        "keyword": "pre_run",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`run` action. Errors do not interrupt the action."
    },
    {
        "sections": ["DEFAULT", "task"],
        "keyword": "post_run",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`run` action. Errors do not interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "blocking_pre_unprovision",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`unprovision` action. Errors interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "blocking_post_unprovision",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`unprovision` action. Errors interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "blocking_pre_provision",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`provision` action. Errors interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "blocking_post_provision",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`provision` action. Errors interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "blocking_pre_start",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`start` action. Errors interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "blocking_post_start",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`start` action. Errors interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "blocking_pre_stop",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`stop` action. Errors interrupt the action."
    },
    {
        "sections": SECTIONS,
        "keyword": "blocking_post_stop",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`stop` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_pre_sync_nodes",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_nodes` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_post_sync_nodes",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_nodes` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_pre_sync_drp",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_drp` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_post_sync_drp",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_drp` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_pre_sync_restore",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_restore` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_post_sync_restore",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_restore` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_pre_sync_resync",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_resync` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_post_sync_resync",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_resync` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_pre_sync_update",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`sync_update` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "keyword": "blocking_post_sync_update",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`sync_update` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "task"],
        "keyword": "blocking_pre_run",
        "generic": True,
        "at": True,
        "text": "A command or script to execute before the resource :c-action:`run` action. Errors interrupt the action."
    },
    {
        "sections": ["DEFAULT", "task"],
        "keyword": "blocking_post_run",
        "generic": True,
        "at": True,
        "text": "A command or script to execute after the resource :c-action:`run` action. Errors interrupt the action."
    },
    {
        "sections": SECTIONS,
        "prefixes": ["unprovision", "provision", "start", "stop"],
        "keyword": "_requires",
        "generic": True,
        "at": True,
        "example": "ip#0 fs#0(down,stdby down)",
        "default": "",
        "text": "A whitespace-separated list of conditions to meet to accept running a '{prefix}' action. A condition is expressed as ``<rid>(<state>,...)``. If states are omitted, ``up,stdby up`` is used as the default expected states."
    },
    {
        "sections": ["DEFAULT", "task"],
        "prefixes": ["run"],
        "keyword": "_requires",
        "generic": True,
        "at": True,
        "example": "ip#0 fs#0(down,stdby down)",
        "default": "",
        "text": "A whitespace-separated list of conditions to meet to accept running a '{prefix}' action. A condition is expressed as ``<rid>(<state>,...)``. If states are omitted, ``up,stdby up`` is used as the default expected states."
    },
    {
        "sections": ["DEFAULT", "sync"],
        "prefixes": ["sync_nodes", "sync_drp", "sync_update", "sync_break", "sync_resync", "sync_restore"],
        "keyword": "_requires",
        "generic": True,
        "at": True,
        "example": "ip#0 fs#0(down,stdby down)",
        "default": "",
        "text": "A whitespace-separated list of conditions to meet to accept running a '{prefix}' action. A condition is expressed as ``<rid>(<state>,...)``. If states are omitted, ``up,stdby up`` is used as the default expected states."
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "pg_cpus",
        "generic": True,
        "inheritance": "leaf",
        "at": True,
        "depends": [('create_pg', [True])],
        "text": "Allow service process to bind only the specified cpus. Cpus are specified as list or range : 0,1,2 or 0-2",
        "example": "0-2"
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "pg_mems",
        "generic": True,
        "inheritance": "leaf",
        "at": True,
        "depends": [('create_pg', [True])],
        "text": "Allow service process to bind only the specified memory nodes. Memory nodes are specified as list or range : 0,1,2 or 0-2",
        "example": "0-2"
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "pg_cpu_shares",
        "generic": True,
        "inheritance": "leaf",
        "at": True,
        "convert": "integer",
        "depends": [('create_pg', [True])],
        "text": "Kernel default value is used, which usually is 1024 shares. In a cpu-bound situation, ensure the service does not use more than its share of cpu ressource. The actual percentile depends on shares allowed to other services.",
        "example": "512"
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "pg_cpu_quota",
        "generic": True,
        "inheritance": "leaf",
        "at": True,
        "depends": [('create_pg', [True])],
        "text": "The percent ratio of one core to allocate to the process group if % is specified, else the absolute value to set in the process group parameter. For example, on Linux cgroups, ``-1`` means unlimited, and a positive absolute value means the number of microseconds to allocate each period. ``50%@all`` means 50% of all cores, and ``50%@2`` means 50% of two cores.",
        "example": "50%@all"
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "pg_mem_oom_control",
        "generic": True,
        "inheritance": "leaf",
        "at": True,
        "convert": "integer",
        "depends": [('create_pg', [True])],
        "text": "A flag (0 or 1) that enables or disables the Out of Memory killer for a cgroup. If enabled (0), tasks that attempt to consume more memory than they are allowed are immediately killed by the OOM killer. The OOM killer is enabled by default in every cgroup using the memory subsystem; to disable it, write 1.",
        "example": "1"
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "pg_mem_limit",
        "generic": True,
        "inheritance": "leaf",
        "at": True,
        "convert": "size",
        "depends": [('create_pg', [True])],
        "text": "Ensures the service does not use more than specified memory (in bytes). The Out-Of-Memory killer get triggered in case of tresspassing.",
        "example": "512000000"
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "pg_vmem_limit",
        "generic": True,
        "inheritance": "leaf",
        "at": True,
        "convert": "size",
        "depends": [('create_pg', [True])],
        "text": "Ensures the service does not use more than specified memory+swap (in bytes). The Out-Of-Memory killer get triggered in case of tresspassing. The specified value must be greater than :kw:`pg_mem_limit`.",
        "example": "1024000000"
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "pg_mem_swappiness",
        "generic": True,
        "inheritance": "leaf",
        "at": True,
        "convert": "integer",
        "depends": [('create_pg', [True])],
        "text": "Set a swappiness value for the process group.",
        "example": "40"
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "pg_blkio_weight",
        "generic": True,
        "inheritance": "leaf",
        "at": True,
        "convert": "integer",
        "depends": [('create_pg', [True])],
        "text": "Block IO relative weight. Value: between 10 and 1000. Kernel default: 1000.",
        "example": "50"
    },
    {
        "sections": SECTIONS + ["subset"],
        "keyword": "comment",
        "default": "",
        "text": "Helps users understand the role of the service and resources, which is nice to on-call support people having to operate on a service they are not usually responsible for."
    },
]


KEYS = KeywordStore(
    provision=True,
    keywords=KEYWORDS,
    deprecated_keywords=DEPRECATED_KEYWORDS,
    reverse_deprecated_keywords=REVERSE_DEPRECATED_KEYWORDS,
    deprecated_sections=DEPRECATED_SECTIONS,
    base_sections=["env", "DEFAULT"],
    template_prefix="template.service.",
)

if __name__ == "__main__":
    if len(sys.argv) == 2:
        fmt = sys.argv[1]
    else:
        fmt = "text"

    KEYS.write_templates(fmt=fmt)
    #print(KEYS.container.getkey("cf"))
    #print(KEYS['DEFAULT'])
