import sys
from env import Env
from core.keywords import KeywordStore

# deprecated => supported
DEPRECATED_KEYWORDS = {
    "node.host_mode": "env",
    "node.environment": "asset_env",
    "node.environnement": "asset_env",
}

# supported => deprecated
REVERSE_DEPRECATED_KEYWORDS = {
    "node.asset_env": ["environnement", "environment"],
    "node.env": ["host_mode"],
}

DEPRECATED_SECTIONS = {
}

BASE_SECTIONS = [
    "node",
    "cluster",
    "compliance",
    "stats",
    "checks",
    "packages",
    "patches",
    "asset",
    "nsr",
    "hds",
    "necism",
    "eva",
    "ibmsvc",
    "vioserver",
    "brocade",
    "disks",
    "sym",
    "rotate_root_pw",
    "listener",
    "syslog",
    "stats_collection",
    "reboot",
    "cluster",
]

PRIVATE_KEYWORDS = [
    {
        "section": "node",
        "keyword": "oci",
        "text": "The default micro-container driver. If not set, prefer podman if installed, fallback to docker."
    },
    {
        "section": "node",
        "keyword": "uuid",
        "text": "The auth token provided by the collector on :cmd:`om node register`."
    },
    {
        "section": "node",
        "keyword": "prkey",
        "default_text": "<autogenerated>",
        "text": "The scsi3 persistent reservation key used by the pr resources."
    },
    {
        "section": "node",
        "keyword": "connect_to",
        "example": "1.2.3.4",
        "text": "An asset information to push to the collector on pushasset, overriding the currently discovered value. On GCE instances, defaults to the instance ip address."
    },
    {
        "section": "node",
        "keyword": "mem_bytes",
        "example": "256mb",
        "convert": "size",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "mem_banks",
        "example": "4",
        "convert": "integer",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "mem_slots",
        "example": "4",
        "convert": "integer",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "os_vendor",
        "example": "Digital",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "os_release",
        "example": "5",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "os_kernel",
        "example": "5.1234",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "os_arch",
        "example": "5.1234",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "cpu_freq",
        "example": "3.2 Ghz",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "cpu_threads",
        "example": "4",
        "convert": "integer",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "cpu_cores",
        "example": "2",
        "convert": "integer",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "cpu_dies",
        "example": "1",
        "convert": "integer",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "cpu_model",
        "example": "Alpha EV5",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "serial",
        "example": "abcdef0123456",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "bios_version",
        "example": "1.025",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "sp_version",
        "example": "1.026",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "enclosure",
        "example": "1",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "tz",
        "example": "+0200",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "manufacturer",
        "example": "Digital",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "node",
        "keyword": "model",
        "example": "ds20e",
        "text": "Override for the corresponding pushasset discovery probe."
    },
    {
        "section": "centera",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushcentera` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "xtremio",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushxtremio` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "array",
        "rtype": "xtremio",
        "keyword": "name",
        "example": "array1",
        "text": "The name of the array. If not provided, fallback to the section name suffix."
    },
    {
        "section": "hp3par",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushhp3par` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "emcvnx",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushvnx` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "freenas",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushfreenas` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "dorado",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushdorado` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "gcedisks",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushgcedisks` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "sym",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushsym` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "nsr",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushnsr` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "hds",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushhds` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "necism",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushnecism` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "eva",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pusheva` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "ibmds",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushibmds` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "ibmsvc",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushibmsvc` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "vioserver",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushvioserver` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "netapp",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushnetapp` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "brocade",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`pushbrocade` node action. See usr/share/doc/schedule for the schedule syntax."
    },
]

KEYWORDS = [
    {
        "section": "node",
        "keyword": "min_avail_mem",
        "default": "2%",
        "convert": "size",
        "text": "The minimum required available memory to allow orchestration."
    },
    {
        "section": "node",
        "keyword": "min_avail_swap",
        "default": "10%",
        "convert": "size",
        "text": "The minimum required available swap to allow orchestration."
    },
    {
        "section": "node",
        "keyword": "env",
        "default": "TST",
        "candidates": Env.allowed_svc_envs,
        "text": "A non-PRD service can not be brought up on a PRD node, but a PRD service can be startup on a non-PRD node (in a DRP situation)."
    },
    {
        "section": "node",
        "keyword": "max_parallel",
        "default": 10,
        "convert": "integer",
        "text": "Allow a maximum of :kw:`max_parallel` subprocesses to run simultaneously on :cmd:`om <selector> --parallel <action>` commands."
    },
    {
        "section": "node",
        "keyword": "allowed_networks",
        "default": ["10.0.0.0/8", "172.16.0.0/24", "192.168.0.0/16"],
        "default_text": "10.0.0.0/8 172.16.0.0/24 192.168.0.0/16",
        "convert": "list",
        "text": "The list of cidr blocks the agents allows creation of backend network into. Should be restricted to match your site constraints."
    },
    {
        "section": "node",
        "keyword": "loc_country",
        "example": "fr",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "loc_city",
        "example": "Paris",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "loc_zip",
        "example": "75017",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "loc_addr",
        "example": "7 rue blanche",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "loc_building",
        "example": "Crystal",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "loc_floor",
        "example": "21",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "loc_room",
        "example": "102",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "loc_rack",
        "example": "R42",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "sec_zone",
        "example": "dmz1",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "team_integ",
        "example": "TINT",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "team_support",
        "example": "TSUP",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "asset_env",
        "example": "Production",
        "text": "An asset information to push to the collector on pushasset, overriding the currently stored value."
    },
    {
        "section": "node",
        "keyword": "dbopensvc",
        "example": "https://collector.opensvc.com",
        "text": "Set the uri of the collector main xmlrpc server. The path part of the uri can be left unspecified. If not set, the agent does not try to communicate with a collector."
    },
    {
        "section": "node",
        "keyword": "dbcompliance",
        "example": "https://collector.opensvc.com/init/compliance/call/xmlrpc",
        "default_text": "Same protocol, server and port as dbopensvc, but with an different path.",
        "text": "Set the uri of the collector's main xmlrpc server. The path part of the uri can be left unspecified."
    },
    {
        "section": "node",
        "keyword": "dblog",
        "convert": "boolean",
        "default": True,
        "text": "If true and dbopensvc is set, the objects action logs are reported to the collector. Set to false to disable log reporting to the collector, event if dbopensvc is set."
    },
    {
        "section": "node",
        "keyword": "branch",
        "example": "1.9",
        "text": "Set the targeted opensvc agent branch. The downloaded upgrades will honor that branch. If not set, the :kw:`repopkg` imposes the target branch, which is not recommended with a public repopkg."
    },
    {
        "section": "node",
        "keyword": "pkg_format",
        "example": "tar",
        "candidates": ["tar", "auto"],
        "default": "auto",
        "text": "Force usage of a package format. Only the tar format can be forced."
    },
    {
        "section": "node",
        "keyword": "repo",
        "example": "http://opensvc.repo.corp",
        "text": """Set the uri of the opensvc agent package repository and compliance modules gzipped tarball repository. This parameter is used by the :cmd:`om node updatepkg` and :cmd:`om node updatecomp` commands.

Expected repository structure::

	ROOT
	+- compliance
	 +- compliance-100.tar.gz
	 +- compliance-101.tar.gz
	 +- current -> compliance-101.tar.gz
	+- packages
	 +- deb
	 +- depot
	 +- pkg
	 +- sunos-pkg
	 +- rpms
	  +- current -> 2.0/current
	  +- 1.9
	   +- current -> opensvc-1.9-50.rpm
	   +- opensvc-1.9-49.rpm
	   +- opensvc-1.9-50.rpm
	  +- 2.0
	   +- current -> opensvc-2.0-90.rpm
	   +- opensvc-2.0-90.rpm
	 +- tbz

"""
    },
    {
        "section": "node",
        "keyword": "repopkg",
        "example": "http://repo.opensvc.com",
        "text": """Set the uri of the opensvc agent package repository. This parameter is used by the :cmd:`om node updatepkg` command.

Expected repository structure::

	ROOT
	+- deb
	+- depot
	+- pkg
	+- sunos-pkg
	+- rpms
	 +- current -> 2.0/current
	 +- 1.9
	  +- current -> opensvc-1.9-50.rpm
	  +- opensvc-1.9-49.rpm
	  +- opensvc-1.9-50.rpm
	 +- 2.0
	  +- current -> opensvc-2.0-90.rpm
	  +- opensvc-2.0-90.rpm
	+- tbz

"""
    },
    {
        "section": "node",
        "keyword": "repocomp",
        "example": "http://compliance.repo.corp",
        "text": """Set the uri of the opensvc compliance modules gzipped tarball repository. This parameter is used by the :cmd:`om node updatecomp` command.

Expected repository structure::

	ROOT
	+- compliance-100.tar.gz
	+- compliance-101.tar.gz
	+- current -> compliance-101.tar.gz

"""
    },
    {
        "section": "node",
        "keyword": "ruser",
        "default": "root",
        "example": "root opensvc@node1",
        "text": """Set the remote user to use to login to a remote node with ssh and rsync. The remote user must have the privileges to run as root the following commands on the remote node:
* om
* rsync
The default ruser is root for all nodes. ruser accepts a list of user[@node] ... If @node is ommited, user is considered the new default user.
"""
    },
    {
        "section": "node",
        "keyword": "maintenance_grace_period",
        "convert": "duration",
        "default": 60,
        "text": "A duration expression, like ``1m30s``, defining how long the daemon retains a remote in-maintenance node data. The maintenance state is announced to peers on daemon stop and daemon restart, but not on daemon shutdown. As long as the remote node data are retained, the local daemon won't opt-in to takeover its running instances. This parameter should be adjusted to span the daemon restart time."
    },
    {
        "section": "node",
        "keyword": "rejoin_grace_period",
        "convert": "duration",
        "default": 90,
        "text": "A duration expression, like ``90m``, defining how long the daemon restrains from taking start decisions if no heartbeat has been received from a peer since daemon startup. This should be adjusted to the maximum delay you can afford to give a chance to services to start on their placement leader after a simultaneous node reboot."
    },
    {
        "section": "node",
        "keyword": "ready_period",
        "convert": "duration",
        "default": 5,
        "text": "A duration expression, like ``10s``, defining how long the daemon monitor waits before starting a service instance in ``ready`` state. A peer node can preempt the start during this period. Usually set to allow at least a couple of heartbeats to be received."
    },
    {
        "section": "dequeue_actions",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`dequeue actions` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "sysreport",
        "keyword": "schedule",
        "default": "00:00-06:00",
        "text": "Schedule parameter for the :c-action:`sysreport` node action, which check all modules and fix only modules flagged ``autofix``. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "compliance",
        "keyword": "schedule",
        "default": "02:00-06:00",
        "text": "Schedule parameter for the :c-action:`compliance auto` node action, which check all modules and fix only modules flagged ``autofix``. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "compliance",
        "keyword": "auto_update",
        "convert": "boolean",
        "default": False,
        "text": "If set to ``true``, and if the execution context indicates a scheduled run, execute :cmd:`om node updatecomp` upon :cmd:`om node compliance check`. This toggle helps keep the compliance modules in sync with the reference repository. Beware of the security impact of this setting: you must be careful your module repository is kept secure."
    },
    {
        "section": "stats",
        "keyword": "schedule",
        "default": "00:00-06:00",
        "text": "Schedule parameter for the :c-action:`pushstats` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "stats",
        "keyword": "disable",
        "convert": "list",
        "example": "blockdev, mem_u",
        "text": "Disable push for a stats group (mem_u, cpu, proc, swap, netdev, netdev_err, block, blockdev, fs_u)."
    },
    {
        "section": "checks",
        "keyword": "schedule",
        "default": "00:00-06:00",
        "text": "Schedule parameter for the :c-action:`pushchecks` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "packages",
        "keyword": "schedule",
        "default": "00:00-06:00",
        "text": "Schedule parameter for the :c-action:`pushpkg` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "patches",
        "keyword": "schedule",
        "default": "00:00-06:00",
        "text": "Schedule parameter for the :c-action:`pushpatch` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "asset",
        "keyword": "schedule",
        "default": "00:00-06:00",
        "text": "Schedule parameter for the :c-action:`pushasset` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "disks",
        "keyword": "schedule",
        "default": "00:00-06:00",
        "text": "Schedule parameter for the :c-action:`pushdisks` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "rotate_root_pw",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`rotate root pw` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "stats_collection",
        "keyword": "schedule",
        "default": "@10",
        "text": "Schedule parameter for the :c-action:`collect stats` node action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "reboot",
        "keyword": "schedule",
        "text": "Schedule parameter for the :c-action:`auto reboot node` action. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "reboot",
        "keyword": "once",
        "convert": "boolean",
        "default": True,
        "text": """If once is set to ``false``, do not remove the reboot flag before rebooting,
so that the node is ready to reboot again in the next allowed timerange.
This setup is needed to enforce a periodic reboot, with a patching script
hooked as a pre trigger for example.
If not set, or set to ``true``, the reboot flag is removed before reboot, and a :cmd:`om node schedule reboot` is needed to rearm.
"""
    },
    {
        "section": "reboot",
        "keyword": "pre",
        "convert": "shlex",
        "example": "yum upgrade -y",
        "text": "A command to execute before reboot. Errors are ignored."
    },
    {
        "section": "reboot",
        "keyword": "blocking_pre",
        "convert": "shlex",
        "example": "yum upgrade -y",
        "text": "A command to execute before reboot. Abort the reboot on error."
    },
    {
        "section": "listener",
        "keyword": "crl",
        "example": "https://crl.opensvc.com",
        "default": Env.paths.crl,
        "text": "The url serving the certificate revocation list. The default points to the path of the cluster ca crl in ``{var}/certs/ca_crl``."
    },
    {
        "section": "listener",
        "keyword": "tls_addr",
        "default": "0.0.0.0",
        "example": "1.2.3.4",
        "text": "The ip addr the daemon tls listener must listen on. Usually set to the cluster vip if 0.0.0.0 is not adequate."
    },
    {
        "section": "listener",
        "keyword": "tls_port",
        "convert": "integer",
        "default": 1215,
        "text": """The port the daemon tls listener must listen on."""
    },
    {
        "section": "listener",
        "keyword": "addr",
        "default": "0.0.0.0",
        "example": "1.2.3.4",
        "text": "The ip addr the daemon listener must listen on."
    },
    {
        "section": "listener",
        "keyword": "port",
        "convert": "integer",
        "default": 1214,
        "text": """The port the daemon listener must listen on. In pull action mode, the collector sends a tcp packet to the server to notify there are actions to unqueue. The opensvc daemon executes the :c-action:`dequeue actions` node action upon receive. The :kw:`listener.port` parameter is sent to the collector upon :c-action:`pushasset`. The collector uses this port to notify the node."""
    },
    {
        "section": "listener",
        "keyword": "openid_well_known",
        "example": "https://keycloak.opensvc.com/auth/realms/clusters/.well-known/openid-configuration",
        "text": "The url serving the well-known configuration of an openid provider. If set, the h2 listener will try to validate the Bearer token provided in the requests. If valid the user name is fetched from the 'preferred_username' claim (fallback on 'name'), and the user grants are fetched from the 'grant' claim. Grant can be a list, in which case a proper grant value is formatted via concatenation of the list elements."
    },
    {
        "section": "syslog",
        "keyword": "facility",
        "default": "daemon",
        "text": """The syslog facility to log to."""
    },
    {
        "section": "syslog",
        "keyword": "level",
        "default": "info",
        "candidates": ["critical", "error", "warning", "info", "debug"],
        "text": "The minimum message criticity to feed to syslog. Setting to critical actually disables the syslog logging, as the agent does not emit message at this level."
    },
    {
        "section": "syslog",
        "keyword": "host",
        "default_text": "localhost if port is set",
        "text": "The syslog host to send logs to. If neither host nor port are specified and if /dev/log exists, the messages are posted to /dev/log."
    },
    {
        "section": "syslog",
        "keyword": "port",
        "default": 514,
        "text": "The syslog host to send logs to. If neither host nor port are specified and if /dev/log exists, the messages are posted to /dev/log."
    },
    {
        "section": "cluster",
        "keyword": "vip",
        "example": "192.168.99.12/24@eth0",
        "at": True,
        "text": "The cluster virtual ip. If configured, the daemon creates a ``system/svc/vip`` failover service to manage this ip."
    },
    {
        "section": "cluster",
        "keyword": "default_mon_format",
        "candidates": ["compact", "matrix"],
        "example": "compact",
        "at": True,
        "text": "The renderer to use with monitor commands, if not explicitely set by the --format option. The compact renderer is optimized for large clusters."
    },
    {
        "section": "cluster",
        "keyword": "dns",
        "convert": "list",
        "default": [],
        "default_text": "",
        "at": True,
        "text": "The list of nodes to set as dns in the containers resolvers. If set, the search will also be set to :c-dns-domain:`<name>.<namespace>.svc.<clustername>`, :c-dns-domain:`<namespace>.svc.<clustername>` and :c-dns-domain:`<clustername>`."
    },
    {
        "section": "cluster",
        "keyword": "ca",
        "default_text": "system/sec/ca-<clustername>",
        "text": "The path of the secret hosting the ca certificate that the listener use to validate clients certificates."
    },
    {
        "section": "cluster",
        "keyword": "cert",
        "default_text": "system/sec/cert-<clustername>",
        "text": "The path of the secret hosting the certificate that the listener use for its tls socket."
    },
    {
        "section": "cluster",
        "keyword": "id",
        "at": True,
        "default_text": "<auto-generated>",
        "text": "This information is fetched from the join command payload received from the joined node."
    },
    {
        "section": "cluster",
        "keyword": "name",
        "at": True,
        "default": "default",
        "text": "The cluster name is used as the zone name in the cluster dns records, in the {fqdn} configuration reference, in the aes secret encryption metadata, in the default name of the secret storing the listener certificate authority (system/sec/ca-<clustername>), in the default name of the secret storing the listener certificate and private key (system/sec/cert-<clustername>). The cluster name should be unique site-wide and be set right before populating secrets. It is always lowercased, so better to set it to a lowercase value to avoid confusion. This information is fetched from the join command payload received from the joined node."
    },
    {
        "section": "cluster",
        "keyword": "secret",
        "at": True,
        "default_text": "<random autogenerated on first use>",
        "text": "The cluster shared secret. Used to encrypt/decrypt data with AES256. This secret is either autogenerated or fetched from a join command."
    },
    {
        "section": "cluster",
        "keyword": "nodes",
        "convert": "list",
        "text": "This list is fetched from the join command payload received from the joined node. The service configuration ``{clusternodes}`` is resolved to this keyword value."
    },
    {
        "section": "cluster",
        "keyword": "drpnodes",
        "convert": "list",
        "text": "This list is fetched from the join command payload received from the joined node. The service configuration ``{clusterdrpnodes}`` is resolved to this keyword value."
    },
    {
        "section": "cluster",
        "keyword": "quorum",
        "convert": "boolean",
        "default": False,
        "text": "Should a split segment of the cluster commit suicide. Default is False. If set to ``true``, please set at least 2 arbitrators so you can rolling upgrade the opensvc daemons."
    },
    {
        "section": "arbitrator",
        "keyword": "name",
        "required": True,
        "text": """The arbitrator resolvable node name.
An arbitrator is a opensvc node (running the usual osvc daemon) this
cluster nodes can ask for a vote when the cluster is split.
Arbitrators are tried in sequence, the first reachable arbitrator
gives a vote. In case of a real split, all arbitrators are expected to
be unreachable from the lost segment. At least one of them is
expected to be reachable from the surviving segment.
Arbitrators of a cluster must thus be located close enough to each
other, so a subset of arbitrators can't be reachable from a split
cluster segment, while another subset of arbitrators is reachable
from the other split cluster segment. But not close enough so they can
all fail together. Usually, this can be interpreted as: same site,
not same rack and power lines.
Arbitrators usually don't run services, even though they could, as their
secret might be known by multiple clusters of different responsibles.
Arbitrators can be tested using :cmd:`om node ping --node <arbitrator name>`.
"""
    },
    {
        "section": "arbitrator",
        "keyword": "secret",
        "required": True,
        "text": "The secret to use to encrypt/decrypt data exchanged with the arbitrator (AES256)."
    },
    {
        "section": "arbitrator",
        "keyword": "timeout",
        "convert": "duration",
        "at": True,
        "default": 5,
        "text": "The maximum time to wait for the arbitrator vote during a quorum election. "
                "Upon expiration, the vote is considered lost for the querying node."
    },
    {
        "section": "stonith",
        "keyword": "cmd",
        "at": True,
        "convert": "shlex",
        "required": True,
        "example": "/bin/true",
        "text": "The command to use to STONITH a peer. Usually comes from a fencing utilities collection. The section rindex is the name of the node to stonith, so one section per node must be added."
    },
    {
        "section": "hb",
        "keyword": "type",
        "candidates": ["unicast", "multicast", "disk", "relay"],
        "required": True,
        "text": "The heartbeat driver name."
    },
    {
        "section": "hb",
        "keyword": "addr",
        "rtype": "unicast",
        "at": True,
        "example": "1.2.3.4",
        "default_text": "0.0.0.0 for listening and to the resolved nodename for sending.",
        "text": "The ip address of each node."
    },
    {
        "section": "hb",
        "keyword": "intf",
        "rtype": "unicast",
        "at": True,
        "default_text": "The natural interface for <addr>",
        "example": "eth0",
        "text": "The interface to bind."
    },
    {
        "section": "hb",
        "keyword": "port",
        "rtype": "unicast",
        "convert": "integer",
        "at": True,
        "default": 10000,
        "text": "The port for each node to send to or listen on."
    },
    {
        "section": "hb",
        "keyword": "timeout",
        "convert": "duration",
        "at": True,
        "default": 15,
        "text": "The delay since the last received heartbeat from a node before considering this node is gone."
    },
    {
        "section": "hb",
        "keyword": "addr",
        "rtype": "multicast",
        "at": True,
        "default": "224.3.29.71",
        "text": "The multicast address to send to and listen on."
    },
    {
        "section": "hb",
        "keyword": "intf",
        "rtype": "multicast",
        "at": True,
        "default_text": "The natural interface for <addr>",
        "example": "eth0",
        "text": "The interface to bind."
    },
    {
        "section": "hb",
        "keyword": "port",
        "rtype": "multicast",
        "convert": "integer",
        "at": True,
        "default": 10000,
        "text": "The port for each node to send to or listen on."
    },
    {
        "section": "hb",
        "keyword": "nodes",
        "at": True,
        "convert": "list",
        "default_text": "All nodes.",
        "text": "The nodes participating to the heartbeat.",
    },
    {
        "section": "hb",
        "keyword": "dev",
        "rtype": "disk",
        "at": True,
        "required": True,
        "text": "The device to write the hearbeats to and read from. It must be dedicated to the daemon use. Its size should be 1M + 1M per cluster node."
    },
    {
        "section": "hb",
        "keyword": "relay",
        "rtype": "relay",
        "required": True,
        "example": "relaynode1",
        "text": "The relay resolvable node name."
    },
    {
        "section": "hb",
        "keyword": "secret",
        "rtype": "relay",
        "required": True,
        "example": "123123123124325543565",
        "text": "The secret to use to encrypt/decrypt data exchanged with the relay (AES256)."
    },
    {
        "section": "cni",
        "keyword": "plugins",
        "default": "/opt/cni/bin",
        "text": "The directory hosting the CNI plugins.",
        "example": "/var/lib/opensvc/cni/bin"
    },
    {
        "section": "cni",
        "keyword": "config",
        "default": "/opt/cni/net.d",
        "text": "The directory hosting the CNI network configuration files.",
        "example": "/var/lib/opensvc/cni/net.d"
    },
    {
        "section": "pool",
        "keyword": "type",
        "default": "directory",
        "candidates": ["directory", "loop", "vg", "zpool", "freenas", "share", "shm", "symmetrix", "virtual", "dorado", "drbd"],
        "text": "The pool type."
    },
    {
        "section": "pool",
        "keyword": "status_schedule",
        "text": "The value to set to the status_schedule keyword of the volume objects allocated from the pool. See usr/share/doc/schedule for the schedule syntax."
    },
    {
        "section": "pool",
        "keyword": "mnt_opt",
        "at": True,
        "text": "The mount options of the fs created over the pool devices."
    },
    {
        "section": "pool",
        "rtype": ["freenas", "symmetrix", "dorado"],
        "keyword": "array",
        "at": True,
        "required": True,
        "text": "The name of the array, known as :c-array:`array#<name>` in the node or cluster configuration."
    },
    {
        "section": "pool",
        "rtype": "symmetrix",
        "keyword": "srp",
        "required": True,
        "text": "The name of the array resource pool to allocate volumes from."
    },
    {
        "section": "pool",
        "rtype": "symmetrix",
        "keyword": "slo",
        "default": None,
        "text": "The name of the Service Level Agreement of the selected Storage Group."
    },
    {
        "section": "pool",
        "rtype": "symmetrix",
        "keyword": "srdf",
        "default": False,
        "text": "Use SRDF replication."
    },
    {
        "section": "pool",
        "rtype": "symmetrix",
        "keyword": "rdfg",
        "default": None,
        "text": "Replication Group to use for SRDF."
    },
    {
        "section": "pool",
        "rtype": ["freenas", "dorado"],
        "keyword": "diskgroup",
        "required": True,
        "text": "The name of the array disk group to allocate volumes from."
    },
    {
        "section": "pool",
        "rtype": "freenas",
        "keyword": "insecure_tpc",
        "convert": "boolean",
        "default": False,
        "text": "Allow initiators to xcopy without authenticating to foreign targets."
    },
    {
        "section": "pool",
        "rtype": "freenas",
        "keyword": "compression",
        "default": "inherit",
        "candidates": ["inherit", "none", "lz4", "gzip-1", "gzip-2", "gzip-3", "gzip-4", "gzip-5", "gzip-6", "gzip-7", "gzip-8", "gzip-9", "zle", "lzjb"],
        "text": "Compression level.",
    },
    {
        "section": "pool",
        "rtype": "freenas",
        "keyword": "sparse",
        "convert": "boolean",
        "default": False,
        "text": "Create zvol in sparse mode."
    },
    {
        "section": "pool",
        "rtype": "freenas",
        "keyword": "blocksize",
        "default": 512,
        "convert": "size",
        "text": "Allow initiators to xcopy without authenticating to foreign targets."
    },
    {
        "section": "pool",
        "rtype": "vg",
        "keyword": "name",
        "required": True,
        "text": "The name of the volume group to allocate the pool volumes logical volumes into."
    },
    {
        "section": "pool",
        "rtype": "drbd",
        "keyword": "vg",
        "text": "The name of the volume group to allocate the pool volumes logical volumes into."
    },
    {
        "section": "pool",
        "rtype": "zpool",
        "keyword": "name",
        "required": True,
        "text": "The name of the zpool to allocate the pool volumes zvol or datasets into."
    },
    {
        "section": "pool",
        "rtype": "drbd",
        "keyword": "zpool",
        "text": "The name of the zpool to allocate the pool volumes zvol into."
    },
    {
        "section": "pool",
        "keyword": "path",
        "rtype": "drbd",
        "text": "The fullpath of the directory hosting the pool volumes loop files."
    },
    {
        "section": "pool",
        "keyword": "path",
        "rtype": "share",
        "default": "{var}/pool/share",
        "text": "The fullpath of the shared directory hosting the pool volumes directories or loop files."
    },
    {
        "section": "pool",
        "keyword": "path",
        "rtype": "directory",
        "default": "{var}/pool/directory",
        "text": "The fullpath of the directory hosting the pool volumes directories or loop files."
    },
    {
        "section": "pool",
        "keyword": "template",
        "rtype": ["virtual"],
        "text": "The service path ``<namespace>/<kind>/<name>`` of a volume to use as a template for new volumes.",
        "example": "templates/vol/mpool-over-loop"
    },
    {
        "section": "pool",
        "keyword": "volume_env",
        "rtype": ["virtual"],
        "convert": "list",
        "example": "container#1.name:container_name env.foo:foo",
        "text": "The list of the volume consumer service config keywords which values are mapped as env keys in the allocated volume service.",
    },
    {
        "section": "pool",
        "keyword": "capabilities",
        "rtype": ["virtual"],
        "convert": "list",
        "default": ["roo", "rwo", "rox", "rwx"],
        "default_text": "roo rwo rox rwx",
        "text": "The capabilities exposed by the virtual pool. Supported capabilities: ``shared``, ``roo``, ``rox``, ``rwo``, ``rwx``, ``blk``",
    },
    {
        "section": "pool",
        "keyword": "path",
        "rtype": "loop",
        "default": "{var}/pool/loop",
        "text": "The path to create the pool loop files in."
    },
    {
        "section": "pool",
        "keyword": "fs_type",
        "default": "xfs",
        "text": "The filesystem to format the pool devices with."
    },
    {
        "section": "pool",
        "keyword": "mkfs_opt",
        "default": [],
        "convert": "shlex",
        "example": "-O largefile",
        "text": "The mkfs command options to use to format the pool devices."
    },
    {
        "section": "pool",
        "keyword": "mkblk_opt",
        "default": [],
        "convert": "shlex",
        "text": "The zvol, lv, and other block device creation command options to use to prepare the pool devices."
    },
    {
        "section": "hook",
        "keyword": "events",
        "default": [],
        "default_text": "",
        "convert": "list",
        "text": "The list of events to execute the hook command on. The special value ``all`` is also supported."
    },
    {
        "section": "hook",
        "keyword": "command",
        "convert": "shlex",
        "text": "The command to execute on selected events. The program is fed the json-formatted event data through stdin."
    },
    {
        "section": "network",
        "keyword": "type",
        "candidates": ["bridge", "routed_bridge", "weave"],
        "default": "bridge",
        "text": "The type of network.",
    },
    {
        "section": "network",
        "rtype": "routed_bridge",
        "keyword": "subnet",
        "at": True,
        "text": "The cidr subnet handled by this node. This parameter must be scoped for each node. Usually, the subnets are allocated automatically upon initial network setup, each node being attributed a subnet based on its index in the cluster.nodes list."
    },
    {
        "section": "network",
        "rtype": "routed_bridge",
        "keyword": "ips_per_node",
        "convert": "integer",
        "default": "1024",
        "text": "The number of allocatable ips per node on the network. Converted to the closest power of two."
    },
    {
        "section": "network",
        "rtype": "routed_bridge",
        "keyword": "tables",
        "default": ["main"],
        "default_text": "main",
        "convert": "list",
        "text": "The list of routing tables to add the backend network routes to. The list of available tables is in ``/etc/iproute2/rt_tables``.",
        "example": "main custom1 custom2"
    },
    {
        "section": "network",
        "rtype": "routed_bridge",
        "keyword": "addr",
        "at": True,
        "default_text": "Detect using a name resolution of <nodename>. Beware, if the nodename resolves to 127.0.1.1 or 127.0.0.1 the ipip tunnel can not work.",
        "text": "The ip address used as local endpoint for the ipip tunnel configured by network setup to access the backend subnet of peer nodes not on the same subnet."
    },
    {
        "section": "network",
        "rtype": "routed_bridge",
        "keyword": "tunnel",
        "default": "auto",
        "candidates": ["auto", "always"],
        "text": "Create and route trafic through tunnels to peer nodes policy. ``auto`` tunnel if the peer is not in the same subnet, ``always`` tunnel even if the peer seems to be in the same subnet (some hosting providers require this as traffic goes through router even between adjacent nodes."
    },
    {
        "section": "network",
        "rtype": ["bridge", "routed_bridge"],
        "keyword": "network",
        "default": "10.22.0.0/16",
        "text": "The cluster backend network. The routed_bridge driver fragments this network into :kw:`ips_per_nodes` blocks subnets."
    },
    {
        "section": "network",
        "rtype": "weave",
        "keyword": "network",
        "default": "10.32.0.0/12",
        "text": "The cluster backend network."
    },
    {
        "section": "switch",
        "keyword": "type",
        "candidates": ["brocade"],
        "required": True,
        "text": "The network switch driver name."
    },
    {
        "section": "switch",
        "rtype": "brocade",
        "keyword": "name",
        "example": "sansw1.my.corp",
        "text": "The name connect to the switch (dns name or ip address). If not set, fallback to the section name suffix."
    },
    {
        "section": "switch",
        "rtype": "brocade",
        "keyword": "username",
        "required": True,
        "example": "admin",
        "text": "The username to use to log in the switch."
    },
    {
        "section": "switch",
        "rtype": "brocade",
        "keyword": "password",
        "example": "mysec/password",
        "text": "The password to use to log in, expressed as a <secname> reference to a secret. The secret must be in the ``system`` namespace and must have the ``password`` key. Either username or key must be specified."
    },
    {
        "section": "switch",
        "rtype": "brocade",
        "keyword": "key",
        "example": "/path/to/key",
        "text": "The path to the private key to use to log in the switch."
    },
    {
        "section": "array",
        "keyword": "type",
        "candidates": ["freenas", "hds", "eva", "nexenta", "vioserver", "centera", "symmetrix", "emcvnx", "netapp", "hp3par", "ibmds", "ibmsvc", "xtremio", "dorado"],
        "required": True,
        "text": "The storage array driver name."
    },
    {
        "section": "pool",
        "rtype": "dorado",
        "keyword": "compression",
        "convert": "boolean",
        "default": True,
        "text": "Activate compression on created luns.",
    },
    {
        "section": "pool",
        "rtype": "dorado",
        "keyword": "dedup",
        "convert": "boolean",
        "default": True,
        "text": "Activate data deduplcation on created luns.",
    },
    {
        "section": "pool",
        "rtype": "dorado",
        "keyword": "hypermetrodomain",
        "required": False,
        "example": "HyperMetroDomain_000",
        "text": "Create LUN as HyperMetro replicated pairs, using this domain."
    },
    {
        "section": "array",
        "rtype": ["freenas", "xtremio", "dorado"],
        "keyword": "api",
        "required": True,
        "example": "https://array.opensvc.com/api/v1.0",
        "text": "The array rest api url."
    },
    {
        "section": "array",
        "rtype": ["centera", "eva", "hds", "ibmds", "ibmsvc", "freenas", "netapp", "nexenta", "vioserver", "xtremio", "dorado"],
        "keyword": "username",
        "required": True,
        "example": "root",
        "text": "The username to use to log in."
    },
    {
        "section": "array",
        "rtype": ["centera", "eva", "hds", "freenas", "nexenta", "xtremio", "dorado"],
        "keyword": "password",
        "example": "system/sec/array1",
        "required": True,
        "text": "The password to use to log in, expressed as a <path> reference to a secret. The secret must be in the ``system`` namespace and must have the ``password`` key."
    },
    {
        "section": "array",
        "rtype": ["freenas", "dorado"],
        "keyword": "timeout",
        "convert": "duration",
        "example": "10s",
        "default": 120,
        "text": "The api request timeout."
    },
    {
        "section": "array",
        "rtype": "dorado",
        "keyword": "name",
        "example": "a09",
        "text": "The name of the array. If not provided, fallback to the section name suffix."
    },
    {
        "section": "array",
        "rtype": "symmetrix",
        "keyword": "name",
        "example": "00012345",
        "text": "The name of the array. If not provided, fallback to the section name suffix."
    },
    {
        "section": "array",
        "rtype": "symmetrix",
        "keyword": "symcli_path",
        "example": "/opt/symcli",
        "text": "Force use of a symcli programs installation, pointing the path of its head directory. For the case multiple symcli versions are installed and the default selector does not select the version preferred for the array."
    },
    {
        "section": "array",
        "rtype": "symmetrix",
        "keyword": "symcli_connect",
        "example": "MY_SYMAPI_SERVER",
        "text": "Set the ``SYMCLI_CONNECT`` environment variable to this value, if set. If not set, the scsi communication channels are used. The value set must be declared in the ``/var/symapi/config/netcnfg`` file."
    },
    {
        "section": "array",
        "rtype": ["emcvnx", "hp3par", "symmetrix"],
        "keyword": "username",
        "example": "root",
        "text": "The username to use to log in, if configured."
    },
    {
        "section": "array",
        "rtype": ["emcvnx", "symmetrix"],
        "keyword": "password",
        "example": "system/sec/array1",
        "text": "The password to use to log in, if configured, expressed as a <path> reference to a secret. The secret must be in the ``system`` namespace and must have the ``password`` key."
    },
    {
        "section": "array",
        "rtype": ["centera", "netapp"],
        "keyword": "server",
        "required": True,
        "example": "centera1",
        "text": "The storage server to connect."
    },
    {
        "section": "array",
        "rtype": "centera",
        "keyword": "java_bin",
        "required": True,
        "example": "/opt/java/bin/java",
        "text": "The path to the java executable to use to run the Centera management program."
    },
    {
        "section": "array",
        "rtype": "centera",
        "keyword": "jcass_dir",
        "required": True,
        "example": "/opt/centera/LIB",
        "text": "The path of the directory hosting the JCASScript.jar."
    },
    {
        "section": "array",
        "rtype": "emcvnx",
        "keyword": "method",
        "default": "secfile",
        "candidates": ["secfile", "credentials"],
        "example": "secfile",
        "text": "The authentication method to use."
    },
    {
        "section": "array",
        "rtype": "emcvnx",
        "keyword": "spa",
        "required": True,
        "example": "array1-a",
        "text": "The name of the Service Processor A."
    },
    {
        "section": "array",
        "rtype": "emcvnx",
        "keyword": "spb",
        "required": True,
        "example": "array1-b",
        "text": "The name of the Service Processor B."
    },
    {
        "section": "array",
        "rtype": "emcvnx",
        "keyword": "scope",
        "default": "0",
        "example": "1",
        "text": "The VNC scope to work in."
    },
    {
        "section": "array",
        "rtype": "eva",
        "keyword": "manager",
        "required": True,
        "example": "evamanager.mycorp",
        "text": "The EVA manager to connect."
    },
    {
        "section": "array",
        "rtype": "eva",
        "keyword": "bin",
        "example": "/opt/sssu/bin/sssu",
        "text": "The EVA manager executable to use."
    },
    {
        "section": "array",
        "rtype": "hds",
        "keyword": "bin",
        "example": "/opt/hds/bin/HiCommandCLI",
        "text": "The HDS manager executable to use."
    },
    {
        "section": "array",
        "rtype": "hds",
        "keyword": "jre_path",
        "example": "/opt/java",
        "text": "The path hosting the java installation to use to execute the HiCommandCLI."
    },
    {
        "section": "array",
        "rtype": "hds",
        "keyword": "name",
        "example": "HUSVM.1234",
        "text": "The name of the array. If not provided, fallback to the section name suffix."
    },
    {
        "section": "array",
        "rtype": "hds",
        "keyword": "url",
        "required": True,
        "example": "https://hdsmanager/",
        "text": "The url passed to HiCommandCli, pointing the manager in charge of the array."
    },
    {
        "section": "array",
        "rtype": "hp3par",
        "keyword": "method",
        "default": "ssh",
        "candidates": ["proxy", "cli", "ssh"],
        "example": "ssh",
        "text": "The connection method to use."
    },
    {
        "section": "array",
        "rtype": "hp3par",
        "keyword": "manager",
        "default_text": "wthe name of the array>",
        "example": "mymanager.mycorp",
        "text": "The array manager host name."
    },
    {
        "section": "array",
        "rtype": "hp3par",
        "keyword": "key",
        "example": "/path/to/key",
        "text": "The path to the private key to use to log in."
    },
    {
        "section": "array",
        "rtype": "hp3par",
        "keyword": "pwf",
        "example": "/path/to/pwf",
        "text": "The path to the 3par password file to use to log in."
    },
    {
        "section": "array",
        "rtype": "hp3par",
        "keyword": "cli",
        "default": "3parcli",
        "example": "/path/to/pwf",
        "text": "The path to the 3par password file to use to log in."
    },
    {
        "section": "array",
        "rtype": "ibmds",
        "keyword": "hmc1",
        "required": True,
        "example": "hmc1.mycorp",
        "text": "The host name of the primary HMC."
    },
    {
        "section": "array",
        "rtype": "ibmds",
        "keyword": "hmc2",
        "required": True,
        "example": "hmc2.mycorp",
        "text": "The host name of the secondary HMC."
    },
    {
        "section": "array",
        "rtype": ["netapp", "ibmsvc", "vioserver"],
        "keyword": "key",
        "required": True,
        "example": "/path/to/key",
        "text": "The path to the private key to use to log in."
    },
    {
        "section": "array",
        "rtype": "nexenta",
        "keyword": "port",
        "default": 2000,
        "convert": "integer",
        "example": "2000",
        "text": "The nexenta administration listener port."
    },
]


KEYS = KeywordStore(
    name="node",
    keywords=PRIVATE_KEYWORDS+KEYWORDS,
    deprecated_keywords=DEPRECATED_KEYWORDS,
    reverse_deprecated_keywords=REVERSE_DEPRECATED_KEYWORDS,
    deprecated_sections=DEPRECATED_SECTIONS,
    template_prefix="template.node.",
    base_sections=BASE_SECTIONS,
    has_default_section=False,
 )

